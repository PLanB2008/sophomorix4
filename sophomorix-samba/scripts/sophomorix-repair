#!/usr/bin/perl -w
# This script (sophomorix-repair) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@linuxmuster.net


# next
# option --log-funny-files /path/to/file : list all files that should not be there in the log file
# time for bind repair: 3s for a user that is in 30 groups
#                       1s for a user that is in 3 groups

# update man page:
# add 4 options delete/repair-bind/links
# remove option --repairlinks (never existed)

# check printout in loglevel2

# If binds are to be used: replace obsolte funktions
   # obsolete functions in SophomorixBase.pm:
   # &Sophomorix::SophomorixBase::create_school_link($login); --> update_pointer_school
   # &create_share_link($login,$group,$group,$group_type);    --> update_pointer


# Bibliotheken
use strict;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use Net::DNS;
use File::Basename;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1; 
use JSON;

use Sophomorix::SophomorixBase qw(
                                 print_line
                                 print_title
                                 time_stamp_AD
                                 time_stamp_file
                                 unlock_sophomorix
                                 lock_sophomorix
                                 log_script_start
                                 log_script_end
                                 log_script_exit
                                 backup_amku_file
                                 get_passwd_charlist
                                 get_plain_password
                                 check_options
                                 config_sophomorix_read
                                 filelist_fetch
                                 remove_whitespace
                                 json_dump
                                 NTACL_set_file
                                 recode_utf8_to_ascii
                                 );
use Sophomorix::SophomorixSambaAD qw(
                                 AD_school_add
                                 AD_bind_admin
                                 AD_unbind_admin
                                 AD_user_create
                                 AD_group_create
                                 AD_group_addmember
                                 AD_group_update
                                 AD_get_schoolname
                                 AD_get_name_tokened
                                 AD_dn_fetch_multivalue
                                 AD_get_AD
                                 AD_dns_get
                                 AD_object_search
                                 get_forbidden_logins
                                    );
my @arguments = @ARGV;


# Variablen für Optionen
$Conf::log_level=1;
my $help=0;
my $info=0;
my $json=0;
my $dump_AD=0;
my $linux=0;
my $school=0;
my $project=0;
my $administrator_home=0;
my $teacherclass=0;
my $teacher_home=0;
my $adminclass=0;
my $student_home=0;
my $all=0;


###############################################################################
# Beginn
###############################################################################
# Configuration Files to be used
# linux
my $repair_linux="$DevelConf::path_conf_devel/repdir/repdir.linux";
# school
my $repair_school="$DevelConf::path_conf_devel/repdir/repdir.school";
# project
my $repair_project="$DevelConf::path_conf_devel/repdir/repdir.project";
# Admin homes
my $repair_administrator_home="$DevelConf::path_conf_devel/repdir/repdir.administrator_home";
# teacherclass
my $repair_teacherclass="$DevelConf::path_conf_devel/repdir/repdir.teacherclass";
# Teacher homes
my $repair_teacher_home="$DevelConf::path_conf_devel/repdir/repdir.teacher_home";
# adminclass
my $repair_adminclass="$DevelConf::path_conf_devel/repdir/repdir.adminclass";
# Student homes
my $repair_student_home="$DevelConf::path_conf_devel/repdir/repdir.student_home";

# Parsen der Optionen
my $testopt=GetOptions(
           "help|h" => \$help,
           "info|i" => \$info,
           "json|j+" => \$json,
           "dump-AD" => \$dump_AD,
           "verbose|v+" => \$Conf::log_level,
           "linux|unix" => \$linux,
           "school" => \$school,
           "project" => \$project,
           "administrator-homes" => \$administrator_home,
           "teacherclass" => \$teacherclass,
           "teacher-homes" => \$teacher_home,
           "adminclass" => \$adminclass,
           "student-homes" => \$student_home,
           "all" => \$all,
          );


# Prüfen, ob Optionen erkannt wurden
&check_options($testopt);


# Reading Configuration
my ($ldap,$root_dse) = &AD_bind_admin();
my $root_dns=&AD_dns_get($root_dse);
my %sophomorix_config=&config_sophomorix_read($ldap,$root_dse);


# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlbeschreibung
   print "\n$scriptname repairs the permissions,owner,groupowner,acls/ntacls ",
         "of a sophomorix installation,\n",
         "reading the permissions from *.repdir files\n\n";
   print('
Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i (not implemented)

  -j --dump-AD

What to repair:

  --linux|unix (repairs all permissions outside of $HOME)
  --school                   (use repdir.school)
  --project                  (use repdir.project)
  --admin-homes              (use repdir.administrator_home)
  --teacherclass             ( use repdir.teacherclass)
  --teacher-homes            (use repdir.teacher_home)
  --adminclass               (use repdir.adminclass)
  --student-homes            (use repdir.student_home)

  -- all                     (use all the above, top to bottom order)

Please see the sophomorix-repair(8) man pages for full documentation
');
   exit;
}



###############################################################################
# Gruppenlisten/Userlisten erstellen
###############################################################################

# ============================================================
# asking AD for users
# ============================================================
&print_title("Asking the system for users ...");

# fetch system data
my ($ref_AD) = &AD_get_AD({ldap=>$ldap,
                           root_dse=>$root_dse,
                           root_dns=>$root_dns,
                           computers=>"TRUE",
                           rooms=>"FALSE",
                           management=>"TRUE",
                           adminclasses=>"FALSE",
                           administratorclasses=>"TRUE",
                           teacherclasses=>"FALSE",
                           projects=>"TRUE",
#                           examaccounts=>"TRUE",
                           users=>"TRUE",
                           dnszones=>"TRUE",
                           dnsnodes=>"TRUE",
             });
my %AD= %$ref_AD; 


# --dump-AD
if ($dump_AD==1){
print "dumcp $dump_AD \n";

    &json_dump({json => $json,
                jsoninfo => "SEARCH",
                jsoncomment => "AD Content",
                hash_ref=>\%AD,
              });
}



# ============================================================
# changing the filesystem
# ============================================================
&log_script_start(@arguments);

# --all
if ($all==1) {
    $linux=1;
    $school=1;
    $project=1;
    $administrator_home=1;
    $teacherclass=1;
    $teacher_home=1;
    $adminclass=1;
    $student_home=1;
}


# --linux
if ($linux==1) {
   &repair_dirs_from_file($repair_linux);
}


# --school
if ($school==1) {
   &repair_dirs_from_file($repair_school);
}


# --project
if ($project==1) {
   &repair_dirs_from_file($repair_project);
}


# --admin-homes
if ($administrator_home==1) {
   &repair_dirs_from_file($repair_administrator_home);
}


# --teacherclass
if ($teacherclass==1) {
   &repair_dirs_from_file($repair_teacherclass);
}


# --teacher-homes
if ($teacher_home==1) {
   &repair_dirs_from_file($repair_teacher_home);
}


# --adminclass
if ($adminclass==1) {
   &repair_dirs_from_file($repair_adminclass);
}


# --student-homes
if ($student_home==1) {
   &repair_dirs_from_file($repair_student_home);
}




&log_script_end(@arguments);


############################################################
# subs
############################################################

sub repair_dirs_from_file {
    my ($directory_file)=@_;
    my $directory_file_base = basename($directory_file);
    my $num=0;
    my $line_num=0;
    &print_title("Repairing from file: $directory_file_base");
    open(DIRS, "<$directory_file")|| die "ERROR: $directory_file $!";
    while (<DIRS>) {
        $line_num++;
        # List with ONE school, so ONE loop is certain
        my @schools=("");
        my $group_type="";
        my $school_count=0;
        my $groupvar_count=0;
        chomp();   
        if ($_ eq ""){next;} # Wenn Zeile Leer, dann aussteigen
        if(/^\#/){next;} # Bei Kommentarzeichen aussteigen

        $num++;
        if (/\@\@SCHOOL\@\@/) {
            @schools = @{ $sophomorix_config{'LISTS'}{'SCHOOLS'} };
            $school_count++;
        }

        if (/\@\@ADMINCLASS\@\@/) {
            $group_type="adminclass";
            $groupvar_count++;
        }
        if (/\@\@TEACHERCLASS\@\@/) {
            $group_type="teacherclass";
            $groupvar_count++;
        }
        if (/\@\@PROJECT\@\@/) {
            $group_type="project";
            $groupvar_count++;
        }
        if (/\@\@MANAGEMENT\@\@/) {
            $group_type="admins";
            $groupvar_count++;
        }

        my ($os,$path, $owner, $groupowner, $permission,$ntacl) = split(/::/);
        my @dirs=split(/\//,$path);
        my @new_dirs=();
        foreach my $dir (@dirs){
            $dir=">".$dir."<"; # add the ><, so that no substrings will be replaced

            # /var
            $dir=~s/>\$path_log</${DevelConf::path_log}/;
            $dir=~s/>\$path_log_user</${DevelConf::path_log_user}/;
            # /home
            $dir=~s/>\$homedir_all_schools</${DevelConf::homedir_all_schools}/;
            $dir=~s/>\$homedir_global</${DevelConf::homedir_global}/;

            # other
            $dir=~s/>\$directory_students</${DevelConf::directory_students}/;
            $dir=~s/>\$directory_projects</${DevelConf::directory_projects}/;
            $dir=~s/>\$directory_management</${DevelConf::directory_management}/;

            # remove <,>
            $dir=~s/^>//g;
            $dir=~s/<$//g;
	    push @new_dirs,$dir;
        }

        $path=join("/",@new_dirs);

        print "------------------------------------------------------------\n";
        print "$num) Line $line_num:  $_:\n";
        if($Conf::log_level>=3){
            print "   Type:     $os\n";
            print "   Owner:    $owner\n";
            print "   Group:    $groupowner\n";
            print "   Perm:     $permission\n";
            print "   NT-ACL:   $ntacl\n";
            print "   Schools:  @schools\n";
        }
        &repair_single_directory($os,$path, $owner, $groupowner, $permission, 
                                 $ntacl, \@schools, $group_type, $groupvar_count);
        print "--- DONE with $num) Line $line_num:  $_---\n";
   }

   close(DIRS);
}



sub repair_single_directory {
    my ($os,$path_with_var, $owner, $groupowner, $permission, 
        $ntacl, $schools, $group_type, $groupvar_count) = @_;
    foreach my $school (@$schools){
        my $path=$path_with_var;
        my $path_smb=$path_with_var;
        $path=~s/\@\@SCHOOL\@\@/$school/;
        $path_smb=~s/\@\@SCHOOL\@\@\///;
        if($Conf::log_level>=3){
            print "   Determining path for school $school:\n";
            print "      * Path after school: $path (smb: $path_smb)\n";
        }
        # determining groups to walk through
        my @groups;
        if ($groupvar_count==0){
            # no vars found -> one single loop
            @groups=("");
        } else {
            # vars found
            if(defined $AD{'lists'}{'by_school'}{$school}{'groups_by_type'}{$group_type}){
                # there is a group list -> use it
                @groups=@{ $AD{'lists'}{'by_school'}{$school}{'groups_by_type'}{$group_type} };
            } else {
                # there is no group list -> avoid the even a single loop 
                @groups=();
	    }
        }

        # group loop
        foreach my $group (@groups){
            my $group_basename=$group;

            # calculating group basename without prefix
            $group_basename=~s/^${school}-//;
            print "working with group $group >$group_basename< ...\n";

            my $path_after_group=$path;
            $path_after_group=~s/\@\@ADMINCLASS\@\@/$group_basename/;
            $path_after_group=~s/\@\@TEACHERCLASS\@\@/$group_basename/;
            $path_after_group=~s/\@\@PROJECT\@\@/$group_basename/;
            $path_after_group=~s/\@\@MANAGEMENT\@\@/management/;
            my $path_after_group_smb=$path_smb;
            $path_after_group_smb=~s/\@\@ADMINCLASS\@\@/$group_basename/;
            $path_after_group_smb=~s/\@\@TEACHERCLASS\@\@/$group_basename/;
            $path_after_group_smb=~s/\@\@PROJECT\@\@/$group_basename/;
            $path_after_group_smb=~s/\@\@MANAGEMENT\@\@/management/;
            if($Conf::log_level>=3){      
                print "      * Path after group:  $path_after_group (smb: $path_after_group_smb)\n";
            }

            # user loop
            my @users=("");
            if ($path_after_group=~/\@\@USER\@\@/) {
                if (defined $AD{'lists'}{'by_school'}{$school}{'users_by_group'}{$group}){
                    @users = @{ $AD{'lists'}{'by_school'}{$school}{'users_by_group'}{$group} };
                } else {
                    print "\n";
                    print "##### No users in $group #####\n";
                    # empty list means do nothing in next loop
                    @users=();
                }
            }
            foreach my $user (@users){
                my $path_after_user=$path_after_group;
                $path_after_user=~s/\@\@USER\@\@/$user/;
                my $path_after_user_smb=$path_after_group_smb;
                $path_after_user_smb=~s/\@\@USER\@\@/$user/;
                if($Conf::log_level>=3){      
                    print "      * Path after user:   $path_after_user (smb: $path_after_user_smb)\n";
	        }
                if ($os eq "SMB"){
                    # smbclient
                    my $smbclient_command="smbclient -U Administrator%'Muster!'".
                                         " //$root_dns/$school -c 'mkdir $path_after_user_smb'";
                    print "\n";
                    print "##### User: $user #####\n";
                    print "$smbclient_command\n";
                    system($smbclient_command);

                    # smbcacls
                    &NTACL_set_file({root_dns=>$root_dns,
                                     school=>$school,
                                     ntacl=>$ntacl,
                                     smbpath=>$path_after_user_smb,
                                   });
               } elsif ($os eq "LINUX"){
                    mkdir $path_after_user;
                    my $chown_command="chown ".$owner.".".$groupowner." ".$path_after_user;
                    print "          $chown_command\n";
                    #system($chown_command);
                    chmod oct($permission), $path_after_user;
                } else {
                    print "\nERROR: $os unknown\n\n";
                    exit;
                }
            }
        }
    }



   #my $korrigieren=1;
   #my $permission_to_set="";

   # $samba
   #my @userliste=();





   # foreach my $gruppe (@$gruppen){
   #       if($Conf::log_level>=3){
   #          print "***** Gruppe ist $gruppe *****\n";
   #       }
   #       # Pfad sichern
   #       my $save_path=$path;
   #       # Owner sichern
   #       my $save_owner=$owner; 

   #       # Group-owner sichern
   #       my $save_groupowner=$groupowner; 

   #       # Userliste evtl. einschränken
   # 	 if ($path=~/\$klassen/ && $path=~/\$schueler/) {
   #          @userliste=&fetchstudents_from_adminclass($gruppe);
   #          #print "Userliste: Nur Klasse\n";
   # 	 } elsif ($path=~/\$projects/ && $path=~/\$members/) {
   #          @userliste=&fetchusers_from_project($gruppe);
   #          #print "Userliste: Nur Workstations\n";
   # 	 } elsif ($path=~/\$raeume/ && $path=~/\$workstation/) {
   #          @userliste=&fetchworkstations_from_room($gruppe);
   #          #print "Userliste: Nur Workstations\n";
   # 	 } else {
   #          my $zahl=@$user;
   #          if (not $zahl==0) {
   #             @userliste=@$user;
   #             #print "Userliste: Alle ($zahl)\n";
   # 	    } else {
   #             @userliste=("");
   #             print "Userliste: User ohne Namen ($zahl User)\n";
   # 	    }
   # 	 }

   #       # Ersetzungen vornehmen von Gruppen
   #       # Bsp.: String $klassen mit dem Wert von $gruppe ersetzen
   #       $path=~s/\$klassen/$gruppe/g; 
   #       $path=~s/\$raeume/$gruppe/g; 
   #       $path=~s/\$projects/$gruppe/g; 
   #       $path=~s/\$subclasses/$gruppe/g; 

   #       $groupowner=~s/\$klassen/$gruppe/g; 
   #       $groupowner=~s/\$raeume/$gruppe/g;
   #       $groupowner=~s/\$projects/$gruppe/g;
   #       $groupowner=~s/\$subclasses/$gruppe/g;

   #    foreach $user (@$user){
   #       if($Conf::log_level>=3){
   #          print "User ist $user\n";
   #       }
   #       # Pfad sichern
   #       my $save_path=$path;         
   #       # Owner sichern
   #       my $save_owner=$owner;
         
   #       # Grou-owner sichern
   #       my $save_groupowner=$groupowner;
         
   #       my $ownerid=0;
   #       my $gid=0;

   #       # Ersetzungen vornehmen von Usern
   #       $path=~s/\$schueler/$user/g; 
   #       $path=~s/\$lehrer/$user/g; 
   #       $path=~s/\$workstation/$user/g; 
   #       $path=~s/\$members/$user/g; 

   #       $owner=~s/\$schueler/$user/g; 
   #       $owner=~s/\$lehrer/$user/g;
   #       $owner=~s/\$workstation/$user/g; 
   #       $owner=~s/\$members/$user/g; 

   #       # use database
   #       ($a,$a,$a,$a,$ownerid) = 
   #          &Sophomorix::SophomorixPgLdap::fetchdata_from_account($owner);
   #       if ($ownerid==-1) {
   #           # use ldap
   # 	     if (not defined($ownerid=getpwnam $owner)){
   #               print "WARNING: Benutzer $owner gibt es nicht!\n";
   #               next;
   # 	     }
   #       }

   #       if (not   defined ($gid = getgrnam $groupowner)) {
   #          print "WARNING: Gruppe $groupowner gibt es nicht!\n";
   #          next;
   #       }

   #       # Anlegen, falls nicht vorhanden
   #       # folgendes nicht mehr verwenden, da rechte unötigerweise verändert werden
   #       #system("install -d $path");
 
   #       if (not -e $path) {
   #          # anlegen
   #          mkdir $path;
             #mkdir $path, oct($permission);
   #       }
   #       # # Mehrere mit / getrente Permissions angegeben -> Liste
   #       if ($permission =~m/\//) {
   #           my @permission_list = split(/\//,$permission);
   #           # Dateirechte des Verzeichnises ermitteln
   #           my ($a,$b,$mode) = stat(${path});
   #           #print "Mode ist $mode\n";
   #           # Umwandeln in übliche Schreibweise
   #           $mode &=07777;
   #           $mode=sprintf "%04o",$mode;

   #           if($Conf::log_level>=2){
   #              print "Permissions are $mode  (Permitted: $permission)\n";
   # 	     }
   #           # Falls Verzeichnisrechte gesetzt werden müssen, 
   #           # auf den ersten Wert setzten 
   #           $permission_to_set=$permission_list[0];
   #           # Sind die Verzeichnisrechte OK
   # 	     foreach my $perm (@permission_list){
   #             if ($mode==$perm) {
   #             #print "VerzeichnisrechteOK\n";
   #             # Verzeichnisrechte wurden in der Liste der zulässigen gefunden
   #             # -> nicht mehr korrigieren
   #             $korrigieren=0;
   #             }
   #           }
   #       } else {
   #         $permission_to_set=$permission;
   #       }

   #       # Bei Bedarf Verzeichnisrechte korrigieren
   #       if ($korrigieren==1) {
   #          chmod oct($permission_to_set), $path;
   #          chown $ownerid, $gid, $path;
   #          print "  * $path $owner($ownerid) ",
   #                "$groupowner($gid) $permission_to_set\n";
   #       } else {
   #          # Verzeichnisrechte nicht korrigieren
   #          chown $ownerid, $gid, $path;
   #          print "  * $path $owner($ownerid) ",
   #                "$groupowner($gid) Rechte: OK\n";
   #          # Korrigier-Variable zurücksetzten
   #          $korrigieren=1;
   # 	 }

   #       # Pfad wiederherstellen
   #       $path=$save_path;
   #       $owner=$save_owner;
   #       $groupowner=$save_groupowner;
   #    }

   #  # Pfad wiederherstellen
   #  $path=$save_path;
   #  $owner=$save_owner;
   #  $groupowner=$save_groupowner;
   #  }

}

