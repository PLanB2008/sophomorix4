#!/usr/bin/perl -w
# This script (sophomorix-check) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@linuxmuster.net

# Bibliotheken
use strict;
#use Quota;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use List::MoreUtils qw(uniq);
use Net::LDAP;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1; 
use File::Basename qw( basename
                       dirname
                     ); 
use Text::Iconv;

use Sophomorix::SophomorixBase qw(
                                 print_line
                                 print_title
                                 time_stamp_AD
                                 time_stamp_file
                                 unlock_sophomorix
                                 lock_sophomorix
                                 log_script_start
                                 log_script_end
                                 log_script_exit
                                 backup_amku_file
                                 get_passwd_charlist
                                 get_plain_password
                                 check_options
                                 config_sophomorix_read
                                 filelist_fetch
                                 );
use Sophomorix::SophomorixSambaAD qw(
                                 AD_ou_add
                                 AD_bind_admin
                                 AD_unbind_admin
                                 AD_user_create
                                 AD_group_create
                                 AD_group_addmember
                                 AD_group_update
                                 AD_get_ou_tokened
                                 AD_get_name_tokened
                                 AD_dn_fetch_multivalue
                                 AD_object_search
                                 get_forbidden_logins
                                    );

my @arguments = @ARGV;

my $time_stamp_file=&time_stamp_file();
my $time_stamp_AD=&time_stamp_AD();
my $user_count=0;

my $ou="";
my $school_token="";
my %users_file=();


# encoding tests
my %firstnames_data=();
my %firstnames_errors=();
my %encoding_check_results=();
my @encodings_to_check=("utf8","ISO_8859-1");

my @loglines=();

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Variablen für Optionen
$Conf::log_level=1;
my $help=0;
my $info=0;
my $list_files=0;
my $lock=0;
my $unlock=0;
my $analyze_encoding="";
my $show_special_char_lines=0;
my $non_umlaut=0;
my @special_char_lines=();

# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$Conf::log_level,
           "info|i" => \$info,
           "list-files" => \$list_files,
           "lock" => \$lock,
           "analyze-encoding=s" => \$analyze_encoding,
           "unlock" => \$unlock,
           "show-special-char-lines" => \$show_special_char_lines,
           "non-umlaut|nonumlaut" => \$non_umlaut,
           "help|h" => \$help,
          );


# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

# Reading Configuration
my ($ldap,$root_dse) = &AD_bind_admin();
my %sophomorix_config=&config_sophomorix_read($ldap,$root_dse);
my @filelist=&filelist_fetch({filetype=>"users",
                              sophomorix_config=>\%sophomorix_config,
                            });

# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
sophomorix-check checks the configured user files and finds out which users should be added, updated, moved and killed


Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info                     (dump configuration hash)
  --list-files                     (list processed files and exit)
  --lock / --unlock

Analyze the encoding of a file:
  --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show Umlaut and other special chars
  --show-special-char-lines --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show special chars (not umlauts)
  --non-umlaut  --show-special-char-lines --analyze-encoding /path/to/students.csv
 
Please see the sophomorix-check(8) man pages for full documentation
');
   print "\n";
   exit;
}


# --unlock
if ($unlock==1) {
    &unlock_sophomorix();
    exit;
}


# --lock
if ($lock==1) {
    &lock_sophomorix("lock",0,@arguments);
    exit;
}


# --info
if ($info==1) {
       print Dumper(%sophomorix_config);
       print "\n";
       &print_title("Reading the following user files:");
       foreach my $file (@filelist){
           print "   * $file\n";
       }
       exit;
   }


# --list-files
if ($list_files==1) {

       &print_title("Reading the following user files:");
       foreach my $file (@filelist){
           print "   * $file\n";
       }
       exit;
   }


# --analyze-encoding
# analyze one file
if ($analyze_encoding ne ""){
    if($Conf::log_level>=3){
        print "\n";
        print "Analyzing encoding\n";
    }
    &reading_firstnames();
    &reading_firstname_errors();
    my $enc=&analyze_encoding($analyze_encoding);
    if ($show_special_char_lines==1){
        my $count=0;
	foreach my $line (@special_char_lines){
            my $conv = Text::Iconv->new($enc,"utf8");
            my $line_utf8 = $conv->convert($line);
            if ($non_umlaut==1){
                # äöüÄÖÜß works because its unicode
                if ($line_utf8=~/[^äöüÄÖÜßa-zA-Z0-9\-\.;_\/\s]/) { 
                    $count++;
                    print "$count)  $line_utf8\n";
                }
            } else {
                    $count++;
                    print "$count)  $line_utf8\n";
            }
        }
    }
    &log_script_exit("",1,1,0,@arguments);
}

&log_script_start(@arguments);


################################################################################
# Start
################################################################################

&AD_unbind_admin($ldap);

# reading and checking all user files
foreach my $user_file (@filelist){
    my $count=0;
    my $filename = basename($user_file);
    $school_token=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL_TOKEN'};
    $ou=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'OU'};
    &print_title("Reading $user_file");
    open(USERS,"$user_file") || 
         die "ERROR: $user_file not found!";  
    while(<USERS>){
        $count++;
        &analyze_user_line($_,$user_file,$filename,$school_token,$ou,$count);
    }
    close(USERS);
}


#    if($Conf::log_level>=2){
        print Dumper(%users_file);
#    }






&log_script_end(@arguments);

################################################################################
# Subroutinen
################################################################################

sub analyze_user_line {
    my ($line,$device_file,$filename,$school_token,$ou,$count) = @_;
    if (/^#/ or /^\s*$/){
        return 0;
    } else {
        chomp($line);
        my ($class,
            $last,
            $first,
            $birthdate,
            $unid,
           )=split(/;/,$line);
        my $class_checked=&check_class($class);
        my $first_checked=&check_first($first);
        my $last_checked=&check_last($last);
        my $birthdate_checked=&check_birthdate($birthdate);
        $users_file{$filename}{$count}{FIRSTNAME}=$first_checked;
    }
}


sub check_class {
    my ($class)=@_;
    return $class;
}


sub check_first {
    my ($first)=@_;
    return $first;

}


sub check_last {
    my ($last)=@_;
    return $last;

}


sub check_birthdate {
    my ($birthdate)=@_;
    return $birthdate;

}


sub reading_firstnames {
    my @datafiles=("firstnames.utf8.txt", 
                   "firstnames.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($first,$first_new) = split(/:/);
            $firstnames_data{$enc}{$first}=0;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for encoding: $enc\n";
        }
        close(DATAFILE);
    }
}


sub reading_firstname_errors {
    my @datafiles=("firstname_errors.utf8.txt", 
                   "firstname_errors.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($error,$message) = split(/:/);
            $message=~s/^\s+ //g;
            $firstnames_errors{$enc}{$error}=$message;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for errors: $enc\n";
        }
        close(DATAFILE);
    }
}




sub analyze_encoding {
    my ($file) = @_;
    # set all result counters to 0
    foreach my $enc (@encodings_to_check){
        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=0;
        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=0;
    }
    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'count_errors'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'result'}="unknown";
  

    # start to analyze file
    &Sophomorix::SophomorixBase::print_title("Analyzing $file for encoding");
    open(DATAFILE, "$file") || 
         die "Fehler: $! $file nicht gefunden!"; 
    my $count=0;
    while (<DATAFILE>){
        $count++;
        chomp();
        if ($_ eq ""){
            next;
        }
        ####################################
        if ($show_special_char_lines==1){
            if ($_=~/[^a-zA-Z0-9\-\.;_\/\s]/) { 
                #print "$_\n";
                push @special_char_lines, "Line ".$count."   ".$_;
                #$special_char_lines{$count}=$line;
            }
        }

        my ($class,$surname,$firstname,$date) = split(/;/);
        # split firstname-field into single firstnames
        # split at 'space' and '-'
        my @firstnames=split(/[ ,-]/, $firstname);
        foreach my $first (@firstnames){
            if ($first=~/[^a-zA-Z\-]/) { 
                # continue with non-standard(~non-ascii) chars
                my $hit_count=0;   
                my $error_count=0; 
                foreach my $enc (@encodings_to_check){
                    my $conv = Text::Iconv->new($enc,"utf8");
                    my $first_utf8 = $conv->convert($first);

                    # check for positive hits (known, valid firstnames)
                    if (exists $firstnames_data{$enc}{$first}){
                        # remember hits
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count hits
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=$new;
                        $hit_count++;
                    }
                    # check for errors
                    if (exists $firstnames_errors{$enc}{$first}){
                        # remember errors
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count errors
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=$new;
                        $hit_count++;
                    }
                }
                # non-hits and non-errors (unknown firstnames) 
                if ($hit_count==0 and $error_count==0){
                    # remember unknown names
                    push @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} }, 
                           { first => "$first", 
                             line => "$_"};
                    # count unknown names
                    my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'};
                    my $new=$old+1;
                    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=$new;
                }
            }
        }
    }

    print "\nEncoding check result for:\n";
    print "   $file\n";

    # calculate sum
    my $oldsum=0;
    foreach my $enc (@encodings_to_check){
        my $sum=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}+
	        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc}=$sum;
        if($sum > $oldsum){
            $encoding_check_results{$file}{'firstnames'}{'result'}=$enc;
        }
    }

    # print valid firstnames
    if($Conf::log_level>=2){
    print "\nValid firstnames: ",
          "($encoding_check_results{$file}{'firstnames'}{'result'} ---> utf8)\n";
    print "==========================================================================\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} } ){
        printf  "%-20s %-12s %-20s\n",
                $item->{first},
                "--->",
                $item->{first_utf8};
    }
    print "--------------------------------------------------------------------------\n";
    }

    # print unknown firstnames
    print "\n";
    print "Unknown firstnames (Please report to info\@linuxmuster.net):\n";
    print "+------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} } ){
        printf  "| %-40s |\n",
                $item->{first},
    }
    print "+------------------------------------------+\n";


    #  print firstnames with errors
    print "\nFirstnames that should be an error (Please report the the School Office):\n";
    print "+---------------------------------------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} } ){
        printf  "| %-15s%-60s|\n",
                $item->{first_utf8},
                $item->{line};
        my $enc_result=$encoding_check_results{$file}{'firstnames'}{'result'};
        printf  "|          ---> %-60s|\n",$firstnames_errors{$enc_result}{ $item->{first} };
        print "+---------------------------------------------------------------------------+\n";
    }



    # print debug dump
    if($Conf::log_level>=3){
        print "Dump of \%encoding_check_results:\n";
        print Dumper(\%encoding_check_results);
    }


    # Print Result
    print "\n";
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "Tested Encodings:",
            "Hits",
            "Errors",
            "Sum";
    print "+---------------------+--------+--------+--------+\n";
    foreach my $enc (@encodings_to_check){
        printf  "| %-20s|%7s |%7s |%7s |\n",
                $enc,
                $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc},
                $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc},
   	        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc};
    }
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "none",
            $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'},
            "",
            "";
    print "+---------------------+--------+--------+--------+\n";
    print "$file:\n",
          "    File-Encoding is $encoding_check_results{$file}{'firstnames'}{'result'}\n"; 
    print "\n";
    close(DATAFILE);
    return $encoding_check_results{$file}{'firstnames'}{'result'};
}

