#!/usr/bin/perl -w
# This script (sophomorix-check) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@linuxmuster.net

# Bibliotheken
use strict;
#use Quota;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use List::MoreUtils qw(uniq);
use Net::LDAP;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1; 
use JSON;
use File::Basename qw( basename
                       dirname
                     ); 
use Text::Iconv;
use Sophomorix::SophomorixBase qw(
                                 print_line
                                 print_title
                                 time_stamp_AD
                                 time_stamp_file
                                 unlock_sophomorix
                                 lock_sophomorix
                                 log_script_start
                                 log_script_end
                                 log_script_exit
                                 backup_amku_file
                                 get_passwd_charlist
                                 get_plain_password
                                 check_options
                                 config_sophomorix_read
                                 filelist_fetch
                                 remove_whitespace
                                 json_dump
                                 recode_utf8_to_ascii
                                 );
use Sophomorix::SophomorixSambaAD qw(
                                 AD_ou_add
                                 AD_bind_admin
                                 AD_unbind_admin
                                 AD_user_create
                                 AD_group_create
                                 AD_group_addmember
                                 AD_group_update
                                 AD_get_ou_tokened
                                 AD_get_name_tokened
                                 AD_dn_fetch_multivalue
                                 AD_get_AD
                                 AD_dns_get
                                 AD_object_search
                                 get_forbidden_logins
                                    );

my @arguments = @ARGV;

my $time_stamp_file=&time_stamp_file();
my $time_stamp_AD=&time_stamp_AD();
my $user_count=0;

my $school="";
my %users_file=();


# encoding tests
my %firstnames_data=();
my %firstnames_errors=();
my %encoding_check_results=();
my @encodings_to_check=("utf8","ISO_8859-1");

my @loglines=();

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Variablen für Optionen
$Conf::log_level=1;
my $help=0;
my $info=0;
my $dump_files=0;
my $dump_AD=0;
my %Match=();
my $dump_matches=0;
my $json=0;
my $list_files=0;
my $lock=0;
my $unlock=0;
my $analyze_encoding="";
my $show_special_char_lines=0;
my $non_umlaut=0;
my @special_char_lines=();
my $follow="";

# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$Conf::log_level,
           "info|i" => \$info,
           "dump-files" => \$dump_files,
           "dump-AD" => \$dump_AD,
           "dump-matches" => \$dump_matches,
           "json|j+" => \$json,
           "list-files" => \$list_files,
           "lock" => \$lock,
           "analyze-encoding=s" => \$analyze_encoding,
           "follow=s" => \$follow,
           "unlock" => \$unlock,
           "show-special-char-lines" => \$show_special_char_lines,
           "non-umlaut|nonumlaut" => \$non_umlaut,
           "help|h" => \$help,
          );


# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

# --follow
my $follow_file="";
my $follow_line="";
if ($follow ne ""){
    ($follow_file,$follow_line)=split(/:/,$follow);
}

# Reading Configuration
my ($ldap,$root_dse) = &AD_bind_admin();
my $root_dns=&AD_dns_get($root_dse);
my %sophomorix_config=&config_sophomorix_read($ldap,$root_dse);
my @filelist=&filelist_fetch({filetype=>"users",
                              sophomorix_config=>\%sophomorix_config,
                            });

# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
sophomorix-check checks the configured user files and finds out which users should be added, updated, moved and killed


Options:
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info

  --list-files                     (list processed files and exit)
  --lock / --unlock

  --follow filename:linenumber     (show what happens to this line)

Analyze the encoding of a file:
  --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show Umlaut and other special chars
  --show-special-char-lines --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show special chars (not umlauts)
  --non-umlaut  --show-special-char-lines --analyze-encoding /path/to/students.csv

Usable encodings in school.conf:
   iconv -l

Dumping data:                     
  -ij / --info --json              (dump configuration)
  --dump-files -j                  (dump contents of user files)
  --dump-AD -j                     (dump AD data)
  --dump-matches -j                (dump matched users)

  -j / --json                      (dump as a nice json object)
  -jj / --json --json              (dump as a compact json object)
  -jjj / --json --json --json      (dump as a perl hash)


 
Please see the sophomorix-check(8) man pages for full documentation
');
   print "\n";
   exit;
}


# --unlock
if ($unlock==1) {
    &unlock_sophomorix();
    exit;
}


# --lock
if ($lock==1) {
    &lock_sophomorix("lock",0,@arguments);
    exit;
}


# --info
if ($info==1) {
    &json_dump({json => $json,
                jsoninfo => "CONFIG",
                jsoncomment => "The sophomorix configuration",
                hash_ref=>\%sophomorix_config,
               });
    print "\n";
    &print_title("Reading the following user files:");
    foreach my $file (@filelist){
        print "   * $file\n";
    }
    exit;
}


# --list-files
if ($list_files==1) {

       &print_title("Reading the following user files:");
       foreach my $file (@filelist){
           print "   * $file\n";
       }
       exit;
   }


# --analyze-encoding
# analyze one file
if ($analyze_encoding ne ""){
    if($Conf::log_level>=3){
        print "\n";
        print "Analyzing encoding\n";
    }
    &reading_firstnames();
    &reading_firstname_errors();
    my $enc=&analyze_encoding($analyze_encoding,$analyze_encoding);
    if ($show_special_char_lines==1){
        my $count=0;
	foreach my $line (@special_char_lines){
            my $conv = Text::Iconv->new($enc,"utf8");
            my $line_utf8 = $conv->convert($line);
            if ($non_umlaut==1){
                # äöüÄÖÜß works because its unicode
                if ($line_utf8=~/[^äöüÄÖÜßa-zA-Z0-9\-\.;_\/\s]/) { 
                    $count++;
                    print "$count)  $line_utf8\n";
                }
            } else {
                    $count++;
                    print "$count)  $line_utf8\n";
            }
        }
    }
    &print_analyzed_encoding($analyze_encoding);
    &log_script_exit("",1,1,0,@arguments);
}

&log_script_start(@arguments);


################################################################################
# Start
################################################################################

# ============================================================
# copy or filter files
# ============================================================
&Sophomorix::SophomorixBase::print_title("Copying/Filtering files to $DevelConf::path_conf_tmp");
foreach my  $user_file (@filelist){
    my $filename = basename($user_file);
    my $source=$user_file;
    my $targer_dir=
    my $target=
        $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'FILTERTARGET'};
    my $filter_script=
        $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'FILTERSCRIPT'};
    
    system("mkdir -p $DevelConf::path_conf_tmp");
    if ($filter_script eq "---"){
        print "   * Copying $filename\n";
        if($Conf::log_level>=2){
            print "cp $source\n  ---> $target\n";
        }
        system("cp $source $target");
    } elsif ($filter_script eq "ERROR_FILTERSCRIPT"){
        print "\nERROR: The configured Filter is not an executable script:\n";
        print "   <$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{FILTERSCRIPT_CONFIGURED}>\n";
        print "\n";
        exit;
    } else {
        # filter script is executable, when in config hash -> run it
        my $filter_script_filename = basename($filter_script);
        my $filter_log_file=$DevelConf::path_conf_tmp."/".$filename."_".$filter_script_filename.".log";
        print "   * Filtering $filename: $filter_script\n";
        print "     * Logging to: $filter_log_file\n";
        system("$filter_script > $filter_log_file  2>&1");
    } 
}


# ============================================================
# analyzing encoding of all filtered user files in tmp
# ============================================================
&reading_firstnames();
&reading_firstname_errors();
foreach my  $user_file (@filelist){
    my $filename = basename($user_file);
    my $user_file_tmp=$DevelConf::path_conf_tmp."/".$filename.".filter";
    # file in tmp    
    &analyze_encoding($user_file,$user_file_tmp);
}


# ============================================================
# reading and checking all filtered user files
# ============================================================
foreach my $user_file (@filelist){
    my $count=0;
    my $filename = basename($user_file);
    my $user_file_tmp=$DevelConf::path_conf_tmp."/".$filename.".filter";
    # fetching some config data
    $school=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'};

    # file in tmp    
    &print_title("Reading $user_file_tmp");
    my $enc_used=&get_encoding($filename);
    open(USERS,"$user_file_tmp") || 
         die "ERROR: $user_file_tmp not found!";  
    while(<USERS>){
        $count++;
        &analyze_user_line($_,$user_file,$user_file_tmp,
                           $filename,$school,$count,$enc_used);
    }
    close(USERS);
}


# --dump-files
if ($dump_files==1){
    &json_dump({json => $json,
                jsoninfo => "USERS",
                jsoncomment => "All users read from all user files",
                hash_ref=>\%users_file,
               });
}


# --follow
# show the line
if ($follow ne ""){
    my $identifier=$users_file{'file'}{$follow_file}{$follow_line}{'identifier_ascii'};
    if (not defined $identifier){
        print "   * Line $follow_line in file $follow_file contains no usable data\n";
    } else {
        print "   * LINE ORIG: $users_file{'identifier_ascii'}{$identifier}{LINE_OLD}\n";
        print "   * LINE UTF8: $users_file{'identifier_ascii'}{$identifier}{LINE_NEW}\n";
    }
}


# ============================================================
# asking AD for users
# ============================================================
&print_title("Asking the system for users ...");

# fetch system data
my ($ref_AD) = &AD_get_AD({ldap=>$ldap,
                           root_dse=>$root_dse,
                           root_dns=>$root_dns,
                           computers=>"FALSE",
                           rooms=>"FALSE",
                           examaccounts=>"TRUE",
                           users=>"TRUE",
                           dnszones=>"FALSE",
                           dnsnodes=>"FALSE",
             });
my %AD= %$ref_AD; 


# --dump-AD
if ($dump_AD==1){
    &json_dump({json => $json,
                jsoninfo => "SEARCH",
                jsoncomment => "AD Content",
                hash_ref=>\%AD,
              });
}


# ============================================================
# Walk thhrough all files and identifiers in %users_file
# ============================================================

&find_unid_matches();

# --migration-ascii-to-utf8
# matched tries to mach with ascii-identifier
# approx-string start with zero, increase by one until all are matched
# maximum 5 or so
# track approx number with matches 
# output matches and approx number
# exit if not all could be matched
#
# the migration match ends with:
#   A) All are matched, write sophomorix.update and exit 
#   B) exit with ERROR
#      show unmatched users
# therefore the following match_functions are not applied:
# marriage, birthdate, ... and such matches () becausethere arent any


# --dump-matches
if ($dump_matches==1){
    &json_dump({json => $json,
                jsoninfo => "MATCH",
                jsoncomment => "File user -> AD matches",
                hash_ref=>\%Match,
              });
}


&AD_unbind_admin($ldap);

&log_script_end(@arguments);



################################################################################
# Subroutinen
################################################################################

sub find_unid_matches {
    foreach my $user_file (@filelist){
        my $filename = basename($user_file);
        foreach my $identifier_ascii ( @{ $users_file{'file'}{$filename}{'identifier_list_ascii'} } ){
            print "$filename:",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                  "$identifier_ascii\n";
            if ($users_file{'identifier_ascii'}{$identifier_ascii}{UNID} ne ""){
                # finding a unid match 
                if ( exists $AD{'lookup'}{'user_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}} ){
                    my $sam=$AD{'lookup'}{'user_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}};
                    my $role=$AD{'lookup'}{'role_by_user'}{$sam};
		    print "  --> unidMATCH: $sam --> ",
                          "$AD{'objectclass'}{'user'}{$role}{$sam}{'IDENTIFIER_UTF8'}\n";
                    # save match in %users_file
                    $Match{'file'}{$filename}{$identifier_ascii}=$sam;

                } else {
                    $Match{'unmatched_after_unid_match'}{$identifier_ascii}="no unid match";
                    ### save unmatched for a shorter List ???
                    print "No unid match\n";
                }
            } else {
                $Match{'unmatched_after_unid_match'}{$identifier_ascii}="no unid, no match possible";
            }
        }
    }
}


sub analyze_user_line {
    my ($line,$file_abs,$file_abs_tmp,$filename,$school,$count,$enc_used) = @_;
    if (/^#/ or /^\s*$/){
        return 0;
    } else {
        chomp($line);
        my ($class_raw,
            $last_raw,
            $first_raw,
            $birthdate_raw,
            $field5,
           )=split(/;/,$line);

        my $class=&check_class($class_raw);
        my $first=&check_first($first_raw);
        my $last=&check_last($last_raw);
        my $birthdate=&check_birthdate($birthdate_raw);
        my $unid="";
        my $login="";
        my $field5_key=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{FIELD5};
        if ($field5_key eq "LOGIN"){
            $login=&check_login($field5);
        } elsif ($field5_key eq "UNID"){
            $unid=&check_unid($field5);
        }

        # converting names to utf8 and then to ascii
        my $conv = Text::Iconv->new($enc_used,"utf8");
        my $first_utf8 = $conv->convert($first);
        my $last_utf8 = $conv->convert($last);
        my $first_ascii =&recode_utf8_to_ascii($first_utf8);
        my $last_ascii =&recode_utf8_to_ascii($last_utf8);
        # identifier
        my $identifier_utf8=join(";", ($last_utf8,$first_utf8,$birthdate));
        my $identifier_ascii=join(";", ($last_ascii,$first_ascii,$birthdate));
        # corrected line
        my $line_new=join(";", ($class,$last_utf8,$first_utf8,$birthdate,$unid));

        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_OLD}=$line;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW}=$line_new;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_ASCII}=$first_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_UTF8}=$first_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_ASCII}=$last_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_UTF8}=$last_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{BIRTHDATE}=$birthdate;
        $users_file{'identifier_ascii'}{$identifier_ascii}{CLASS}=$class;
        $users_file{'identifier_ascii'}{$identifier_ascii}{UNID}=$unid;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LOGIN}=$login;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE}=$filename;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_ASCII}=$identifier_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_UTF8}=$identifier_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}=$count;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE_ABS}=$file_abs;

        # add here more stuff to create sophomorix.add, ...
        $users_file{'identifier_ascii'}{$identifier_ascii}{ROLE}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{RT_sophomorixRole};
        $users_file{'identifier_ascii'}{$identifier_ascii}{OU}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{OU};
        $users_file{'identifier_ascii'}{$identifier_ascii}{SCHOOL}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{SCHOOL};

        # identifier list
        push @{ $users_file{'file'}{$filename}{'identifier_list_ascii'} }, $identifier_ascii;
        push @{ $users_file{'file'}{$filename}{'identifier_list_utf8'} }, $identifier_utf8;

        # file -> line
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_ASCII'}=$identifier_ascii;
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_UTF8'}=$identifier_utf8;
    }
}


sub check_class {
    my ($class)=@_;
    $class=&remove_whitespace($class);
    # convert to small letters
    $class=~tr/A-Z/a-z/; 
    # sternchenklassen filtern ?????
    # klassen filtern ?????
    $class=~s/\//$DevelConf::replace_slash_with/g;

    if ($class eq "lehrer" or 
        $class eq "Lehrer"
       ){
        $class=$DevelConf::teacher;
    }
    return $class;
}


sub check_first {
    my ($first)=@_;
    $first=&remove_whitespace($first);
    return $first;
}


sub check_last {
    my ($last)=@_;
    $last=&remove_whitespace($last);
    return $last;
}


sub check_birthdate {
    my ($birthdate)=@_;
    $birthdate=&remove_whitespace($birthdate);
    my $dot_count=$birthdate=~tr/\.//;
    if ($dot_count==2){
        if($Conf::log_level>=3){
            print " ... $dot_count dots in date found ... OK\n";
	}
    } elsif ($birthdate eq ""){
        if($Conf::log_level>=3){
            print " ... Date is empty, Line not corrupted ...\n";
	}
    } else {
	#$datum_korrupt=1;
        print " ... $dot_count dots in date found ... ERROR\n";
	#$datum_korrupt_anzahl++;
          
        # Eintrag in report.admin
        #push (@admin_list_corrupt, "Corrupted Line (" , $punkte_anzahl ,
        #                  " dots in date):\n" , $_ , "\n\n");
        # Set tag for Abbruch
        #$tag = "0"  
    }

    my ($day,$month,$year)=split(/\./,$birthdate);

    # Instead of undefined use empty string
    # this avoids errors
    if (not defined $day){
        $day="";
    }
    if (not defined $month){
        $month="";
    }
    if (not defined $year){
        $year="";
    }

    my $birthdate_ok = join(".",($day,$month,$year));
    return $birthdate_ok;
}


sub check_unid {
    my ($unid)=@_;
    $unid=&remove_whitespace($unid);
    return $unid;
}


sub check_login {
    my ($login)=@_;
    $login=&remove_whitespace($login);
    return $login;
}


sub reading_firstnames {
    my @datafiles=("firstnames.utf8.txt", 
                   "firstnames.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($first,$first_new) = split(/:/);
            $firstnames_data{$enc}{$first}=0;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for encoding: $enc\n";
        }
        close(DATAFILE);
    }
}


sub reading_firstname_errors {
    my @datafiles=("firstname_errors.utf8.txt", 
                   "firstname_errors.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($error,$message) = split(/:/);
            $message=~s/^\s+ //g;
            $firstnames_errors{$enc}{$error}=$message;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for errors: $enc\n";
        }
        close(DATAFILE);
    }
}



sub get_encoding {
    my ($filename)=@_;
    my $enc_used;
    my $enc=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING};
    my $enc_force=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_FORCE};
    my $enc_checked=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED};
    print "   * ENCODING:          $enc\n";
    print "   * ENCODING_FORCE:    $enc_force\n";
    print "   * ENCODING_CHECKED:  $enc_checked\n";

    # misconfigured *.school.conf: exit
    if ($enc eq "ERROR_ENCODING"){
        print "   * Misconfigured ENCODING in configuration file, see \"iconv --list\"\n";
        exit;
    }   
    if ($enc_force eq "ERROR_ENCODING_FORCE"){
        print "   * Misconfigured ENCODING_FORCE in configuration file\n";
        exit;
    }   
 
    # auto setting
    if ($enc eq "auto" and $enc_force eq "no"){
        # auto
        if ($enc_checked eq "unknown"){
            print "   * ENCODING could not be checked automatically\n";
            print "   * Set ENCODING to the desired value and ENCODING_FORCE to \"yes\"\n";
            exit;
        }
        $enc_used=$enc_checked;
    } elsif ($enc ne "auto" and $enc_force eq "no"){
        # auto mismatch configure
        print "   * Misconfigured ENCODING in configuration file and ENCODING_CHECKED do not match\n";
        print "   * Set ENCODING_FORCE to \"yes\" if you know better than sophomorix\n";
        exit;
    } elsif ($enc ne "auto" and $enc_force eq "yes"){
        $enc_used=$enc;
    }

    print "           ---> Using:  $enc_used\n";
    return $enc_used;
}


sub analyze_encoding {
    my ($file,$file_tmp) = @_;
    # $file ist for printout anh path in config hash only
    # $file_tmp will be analyzed
    my $filename = basename($file);
    my $filename_tmp = basename($file_tmp);
    # set all result counters to 0
    foreach my $enc (@encodings_to_check){
        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=0;
        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=0;
    }
    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'count_errors'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'result'}="unknown";

    # start to analyze file_tmp
    &Sophomorix::SophomorixBase::print_title("Encode-analyze $filename_tmp");
    open(DATAFILE, "$file_tmp") || 
         die "Fehler: $! $file_tmp not found!"; 
    my $count=0;
    while (<DATAFILE>){
        $count++;
        chomp();
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }

        ####################################
        if ($show_special_char_lines==1){
            if ($_=~/[^a-zA-Z0-9\-\.;_\/\s]/) { 
                push @special_char_lines, "Line ".$count."   ".$_;
                #$special_char_lines{$count}=$line;
            }
        }
        my ($class,$surname,$firstname,$date) = split(/;/);
        # split firstname-field into single firstnames
        # split at 'space' and '-'
        my @firstnames=split(/[ ,-]/, $firstname);
        foreach my $first (@firstnames){
            if ($first=~/[^a-zA-Z\-]/) { 
                # continue with non-standard(~non-ascii) chars
                my $hit_count=0;   
                my $error_count=0; 
                foreach my $enc (@encodings_to_check){
                    my $conv = Text::Iconv->new($enc,"utf8");
                    my $first_utf8 = $conv->convert($first);

                    # check for positive hits (known, valid firstnames)
                    if (exists $firstnames_data{$enc}{$first}){
                        # remember hits
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count hits
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=$new;
                        $hit_count++;
                    }
                    # check for errors
                    if (exists $firstnames_errors{$enc}{$first}){
                        # remember errors
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count errors
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=$new;
                        $hit_count++;
                    }
                }
                # non-hits and non-errors (unknown firstnames) 
                if ($hit_count==0 and $error_count==0){
                    # remember unknown names
                    push @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} }, 
                           { first => "$first", 
                             line => "$_"};
                    # count unknown names
                    my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'};
                    my $new=$old+1;
                    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=$new;
                }
            }
        }
    }

    # calculate sum
    my $oldsum=0;
    foreach my $enc (@encodings_to_check){
        my $sum=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}+
	        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc}=$sum;
        if($sum > $oldsum){
            $encoding_check_results{$file}{'firstnames'}{'result'}=$enc;
        }
    }
    # save result in config hash
    $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED}=
        $encoding_check_results{$file}{'firstnames'}{'result'};
    if($Conf::log_level>=2){
        print "$file_tmp --> $encoding_check_results{$file}{'firstnames'}{'result'}\n";
    }
    return $encoding_check_results{$file}{'firstnames'}{'result'};
}



sub print_analyzed_encoding {
    my ($file) = @_;
    print "\nEncoding check result for:\n";
    print "   $file\n";

    # print valid firstnames
    if($Conf::log_level>=2){
    print "\nValid firstnames: ",
          "($encoding_check_results{$file}{'firstnames'}{'result'} ---> utf8)\n";
    print "==========================================================================\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} } ){
        printf  "%-20s %-12s %-20s\n",
                $item->{first},
                "--->",
                $item->{first_utf8};
    }
    print "--------------------------------------------------------------------------\n";
    }

    # print unknown firstnames
    print "\n";
    print "Unknown firstnames (Please report to info\@linuxmuster.net):\n";
    print "+------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} } ){
        printf  "| %-40s |\n",
                $item->{first},
    }
    print "+------------------------------------------+\n";

    #  print firstnames with errors
    print "\nFirstnames that should be an error (Please report the the School Office):\n";
    print "+---------------------------------------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} } ){
        printf  "| %-15s%-60s|\n",
                $item->{first_utf8},
                $item->{line};
        my $enc_result=$encoding_check_results{$file}{'firstnames'}{'result'};
        printf  "|          ---> %-60s|\n",$firstnames_errors{$enc_result}{ $item->{first} };
        print "+---------------------------------------------------------------------------+\n";
    }

    # print debug dump
    if($Conf::log_level>=3){
        print "Dump of \%encoding_check_results:\n";
        print Dumper(\%encoding_check_results);
    }

    # Print Result
    print "S\n";
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "Tested Encodings:",
            "Hits",
            "Errors",
            "Sum";
    print "+---------------------+--------+--------+--------+\n";
    foreach my $enc (@encodings_to_check){
        printf  "| %-20s|%7s |%7s |%7s |\n",
                $enc,
                $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc},
                $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc},
   	        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc};
    }
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "none",
            $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'},
            "",
            "";
    print "+---------------------+--------+--------+--------+\n";
    print "$file:\n",
          "    File-Encoding is $encoding_check_results{$file}{'firstnames'}{'result'}\n"; 
    print "\n";
    close(DATAFILE);
}
