#!/usr/bin/perl -w
# This script (sophomorix-check) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@linuxmuster.net

# Bibliotheken
use strict;
#use Quota;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use List::MoreUtils qw(uniq);
use Net::LDAP;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1; 
use File::Basename qw( basename
                       dirname
                     ); 
use Text::Iconv;

use Sophomorix::SophomorixBase qw(
                                 print_line
                                 print_title
                                 time_stamp_AD
                                 time_stamp_file
                                 unlock_sophomorix
                                 lock_sophomorix
                                 log_script_start
                                 log_script_end
                                 log_script_exit
                                 backup_amku_file
                                 get_passwd_charlist
                                 get_plain_password
                                 check_options
                                 config_sophomorix_read
                                 filelist_fetch
                                 remove_whitespace
                                 );
use Sophomorix::SophomorixSambaAD qw(
                                 AD_ou_add
                                 AD_bind_admin
                                 AD_unbind_admin
                                 AD_user_create
                                 AD_group_create
                                 AD_group_addmember
                                 AD_group_update
                                 AD_get_ou_tokened
                                 AD_get_name_tokened
                                 AD_dn_fetch_multivalue
                                 AD_get_AD
                                 AD_dns_get
                                 AD_object_search
                                 get_forbidden_logins
                                    );

my @arguments = @ARGV;

my $time_stamp_file=&time_stamp_file();
my $time_stamp_AD=&time_stamp_AD();
my $user_count=0;

my $ou="";
my $school_token="";
my %users_file=();


# encoding tests
my %firstnames_data=();
my %firstnames_errors=();
my %encoding_check_results=();
my @encodings_to_check=("utf8","ISO_8859-1");

my @loglines=();

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Variablen für Optionen
$Conf::log_level=1;
my $help=0;
my $info=0;
my $list_files=0;
my $lock=0;
my $unlock=0;
my $analyze_encoding="";
my $show_special_char_lines=0;
my $non_umlaut=0;
my @special_char_lines=();
my $follow="";

# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$Conf::log_level,
           "info|i" => \$info,
           "list-files" => \$list_files,
           "lock" => \$lock,
           "analyze-encoding=s" => \$analyze_encoding,
           "follow=s" => \$follow,
           "unlock" => \$unlock,
           "show-special-char-lines" => \$show_special_char_lines,
           "non-umlaut|nonumlaut" => \$non_umlaut,
           "help|h" => \$help,
          );


# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

# --follow
my $follow_file="";
my $follow_line="";
if ($follow ne ""){
    ($follow_file,$follow_line)=split(/:/,$follow);
}

# Reading Configuration
my ($ldap,$root_dse) = &AD_bind_admin();
my $root_dns=&AD_dns_get($root_dse);
my %sophomorix_config=&config_sophomorix_read($ldap,$root_dse);
my @filelist=&filelist_fetch({filetype=>"users",
                              sophomorix_config=>\%sophomorix_config,
                            });

# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
sophomorix-check checks the configured user files and finds out which users should be added, updated, moved and killed


Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info                     (dump configuration hash)
  --list-files                     (list processed files and exit)
  --lock / --unlock

  --follow filename:linenumber     (show what happens to this line)

Analyze the encoding of a file:
  --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show Umlaut and other special chars
  --show-special-char-lines --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show special chars (not umlauts)
  --non-umlaut  --show-special-char-lines --analyze-encoding /path/to/students.csv
 
Please see the sophomorix-check(8) man pages for full documentation
');
   print "\n";
   exit;
}


# --unlock
if ($unlock==1) {
    &unlock_sophomorix();
    exit;
}


# --lock
if ($lock==1) {
    &lock_sophomorix("lock",0,@arguments);
    exit;
}


# --info
if ($info==1) {
       print Dumper(%sophomorix_config);
       print "\n";
       &print_title("Reading the following user files:");
       foreach my $file (@filelist){
           print "   * $file\n";
       }
       exit;
   }


# --list-files
if ($list_files==1) {

       &print_title("Reading the following user files:");
       foreach my $file (@filelist){
           print "   * $file\n";
       }
       exit;
   }


# --analyze-encoding
# analyze one file
if ($analyze_encoding ne ""){
    if($Conf::log_level>=3){
        print "\n";
        print "Analyzing encoding\n";
    }
    &reading_firstnames();
    &reading_firstname_errors();
    my $enc=&analyze_encoding($analyze_encoding,$analyze_encoding);
    if ($show_special_char_lines==1){
        my $count=0;
	foreach my $line (@special_char_lines){
            my $conv = Text::Iconv->new($enc,"utf8");
            my $line_utf8 = $conv->convert($line);
            if ($non_umlaut==1){
                # äöüÄÖÜß works because its unicode
                if ($line_utf8=~/[^äöüÄÖÜßa-zA-Z0-9\-\.;_\/\s]/) { 
                    $count++;
                    print "$count)  $line_utf8\n";
                }
            } else {
                    $count++;
                    print "$count)  $line_utf8\n";
            }
        }
    }
    &print_analyzed_encoding($analyze_encoding);
    &log_script_exit("",1,1,0,@arguments);
}

&log_script_start(@arguments);


################################################################################
# Start
################################################################################

# ============================================================
# copy or filter files
# ============================================================
foreach my  $user_file (@filelist){
    my $filename = basename($user_file);
    my $source=$user_file;
    my $targer_dir=
    my $target=
        $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_FILTER'};
    my $filter_script=
        $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_FILTER_SCRIPT'};
    if (-x $filter_script){
        # script is executable
        system("mkdir -p $DevelConf::path_conf_tmp");
        print "calling filter script $filter_script\n";
        system($filter_script);
    } elsif ($filter_script =~ m/^\//){
        # first char is a /
        my $text="ERROR: Could not find executable filter script $filter_script";
        &log_script_exit($text,0,1,0,@arguments);
    } else {
        system("mkdir -p $DevelConf::path_conf_tmp");
        print "cp $source $target\n";
        system("cp $source $target");
    }
}


# ============================================================
# analyzing encoding of all user files
# ============================================================
&reading_firstnames();
&reading_firstname_errors();
foreach my  $user_file (@filelist){
    my $filename = basename($user_file);
    my $user_file_tmp=$DevelConf::path_conf_tmp."/".$filename.".filter";
    # file in tmp    
    &analyze_encoding($user_file,$user_file_tmp);
}


# ============================================================
# reading and checking all user files
# ============================================================
foreach my $user_file (@filelist){
    my $count=0;
    my $filename = basename($user_file);
    my $user_file_tmp=$DevelConf::path_conf_tmp."/".$filename.".filter";
    # fetching some config data
    $school_token=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL_TOKEN'};
    $ou=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'OU'};

    # file in tmp    
    
    &print_title("Reading $user_file_tmp");
    open(USERS,"$user_file_tmp") || 
         die "ERROR: $user_file_tmp not found!";  
    while(<USERS>){
        $count++;
        &analyze_user_line($_,$user_file,$user_file_tmp,
                           $filename,$school_token,$ou,$count);
    }
    close(USERS);
}


# dumping user in files
if($Conf::log_level>=2){
    &print_title("Hash \%users_file follows:");
    print Dumper(%users_file);
}


# --follow
# show the line
if ($follow ne ""){
    my $identifier=$users_file{'file'}{$follow_file}{$follow_line}{'identifier'};
    if (not defined $identifier){
        print "   * Line $follow_line in file $follow_file contains no usable data\n";
    } else {
        print "   * LINE ORIG: $users_file{'identifier'}{$identifier}{LINE_OLD}\n";
        print "   * LINE UTF8: $users_file{'identifier'}{$identifier}{LINE_NEW}\n";
    }
}


# ============================================================
# asking AD for users
# ============================================================
&print_title("Asking the system for users ...");

# fetch system data
my ($ref_AD) = &AD_get_AD({ldap=>$ldap,
                           root_dse=>$root_dse,
                           root_dns=>$root_dns,
                           computers=>"FALSE",
                           rooms=>"FALSE",
                           examaccounts=>"TRUE",
                           users=>"TRUE",
                           dnszones=>"FALSE",
                           dnsnodes=>"FALSE",
             });
my %AD= %$ref_AD; 


# dumping user in AD
if($Conf::log_level>=2){
    &print_title("Hash \%AD follows:");
    print Dumper(%AD);
}



&AD_unbind_admin($ldap);

&log_script_end(@arguments);

################################################################################
# Subroutinen
################################################################################

sub analyze_user_line {
    my ($line,$file_abs,$file_abs_tmp,$filename,$school_token,$ou,$count) = @_;
    if (/^#/ or /^\s*$/){
        return 0;
    } else {
        chomp($line);
        my ($class_raw,
            $last_raw,
            $first_raw,
            $birthdate_raw,
            $field5,
           )=split(/;/,$line);

        my $class=&check_class($class_raw);
        my $first=&check_first($first_raw);
        my $last=&check_last($last_raw);

        # converting names to utf8
        my $conv = Text::Iconv->new(
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED},
            "utf8");
        my $first_utf8 = $conv->convert($first);
        my $last_utf8 = $conv->convert($last);

        my $birthdate=&check_birthdate($birthdate_raw);
        my $unid="";
        my $login="";
        my $field5_key=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{FIELD5};
        if ($field5_key eq "LOGIN"){
            $login=&check_login($field5);
        } elsif ($field5_key eq "UNID"){
            $unid=&check_unid($field5);
        }

        # todo:
        # password creation/passwodrv

        my $identifier=join(";", ($last,$first,$birthdate));
        my $line_new=join(";", ($class,$last_utf8,$first_utf8,$birthdate,$unid));

        $users_file{'identifier'}{$identifier}{LINE_OLD}=$line;
        $users_file{'identifier'}{$identifier}{LINE_NEW}=$line_new;
        $users_file{'identifier'}{$identifier}{FIRSTNAME}=$first;
        $users_file{'identifier'}{$identifier}{FIRSTNAME_UTF8}=$first_utf8;
        $users_file{'identifier'}{$identifier}{LASTNAME}=$last;
        $users_file{'identifier'}{$identifier}{LASTNAME_UTF8}=$last_utf8;
        $users_file{'identifier'}{$identifier}{BIRTHDATE}=$birthdate;
        $users_file{'identifier'}{$identifier}{CLASS}=$class;
        $users_file{'identifier'}{$identifier}{UNID}=$unid;
        $users_file{'identifier'}{$identifier}{LOGIN}=$login;
        $users_file{'identifier'}{$identifier}{FILE}=$filename;
        $users_file{'identifier'}{$identifier}{LINE_COUNT}=$count;
        $users_file{'identifier'}{$identifier}{FILE_ABS}=$file_abs;

        # add here more stuff to create sophomorix.add, ...
        $users_file{'identifier'}{$identifier}{ROLE}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{RT_sophomorixRole};
        $users_file{'identifier'}{$identifier}{OU}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{OU};
        $users_file{'identifier'}{$identifier}{SCHOOL_TOKEN}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{SCHOOL_TOKEN};

        # file -> line
        $users_file{'file'}{$filename}{$count}{'identifier'}=$identifier;
        $users_file{'file'}{$filename}{$count}{'identifier_worldwide'}=$identifier;

    }
}


sub check_class {
    my ($class)=@_;
    $class=&remove_whitespace($class);
    # convert to small letters
    $class=~tr/A-Z/a-z/; 
    # sternchenklassen filtern ?????
    # klassen filtern ?????
    $class=~s/\//$DevelConf::replace_slash_with/g;

    if ($class eq "lehrer" or 
        $class eq "Lehrer"
       ){
        $class=$DevelConf::teacher;
    }
    return $class;
}


sub check_first {
    my ($first)=@_;
    $first=&remove_whitespace($first);
    return $first;
}


sub check_last {
    my ($last)=@_;
    $last=&remove_whitespace($last);
    return $last;
}


sub check_birthdate {
    my ($birthdate)=@_;
    $birthdate=&remove_whitespace($birthdate);
    my $dot_count=$birthdate=~tr/\.//;
    if ($dot_count==2){
        if($Conf::log_level>=3){
            print " ... $dot_count dots in date found ... OK\n";
	}
    } elsif ($birthdate eq ""){
        if($Conf::log_level>=3){
            print " ... Date is empty, Line not corrupted ...\n";
	}
    } else {
	#$datum_korrupt=1;
        print " ... $dot_count dots in date found ... ERROR\n";
	#$datum_korrupt_anzahl++;
          
        # Eintrag in report.admin
        #push (@admin_list_corrupt, "Corrupted Line (" , $punkte_anzahl ,
        #                  " dots in date):\n" , $_ , "\n\n");
        # Set tag for Abbruch
        #$tag = "0"  
    }

    my ($day,$month,$year)=split(/\./,$birthdate);

    # Instead of undefined use empty string
    # this avoids errors
    if (not defined $day){
        $day="";
    }
    if (not defined $month){
        $month="";
    }
    if (not defined $year){
        $year="";
    }

    my $birthdate_ok = join(".",($day,$month,$year));
    return $birthdate_ok;
}


sub check_unid {
    my ($unid)=@_;
    $unid=&remove_whitespace($unid);
    return $unid;
}


sub check_login {
    my ($login)=@_;
    $login=&remove_whitespace($login);
    return $login;
}


sub reading_firstnames {
    my @datafiles=("firstnames.utf8.txt", 
                   "firstnames.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($first,$first_new) = split(/:/);
            $firstnames_data{$enc}{$first}=0;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for encoding: $enc\n";
        }
        close(DATAFILE);
    }
}


sub reading_firstname_errors {
    my @datafiles=("firstname_errors.utf8.txt", 
                   "firstname_errors.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($error,$message) = split(/:/);
            $message=~s/^\s+ //g;
            $firstnames_errors{$enc}{$error}=$message;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for errors: $enc\n";
        }
        close(DATAFILE);
    }
}






sub analyze_encoding {
    my ($file,$file_tmp) = @_;
    my $filename = basename($file);
    my $filename_tmp = basename($file_tmp);
    # set all result counters to 0
    foreach my $enc (@encodings_to_check){
        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=0;
        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=0;
    }
    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'count_errors'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'result'}="unknown";

    # start to analyze file
    &Sophomorix::SophomorixBase::print_title("Encode-analyzing $file");
    open(DATAFILE, "$file") || 
         die "Fehler: $! $file nicht gefunden!"; 
    my $count=0;
    while (<DATAFILE>){
        $count++;
        chomp();
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }

        ####################################
        if ($show_special_char_lines==1){
            if ($_=~/[^a-zA-Z0-9\-\.;_\/\s]/) { 
                push @special_char_lines, "Line ".$count."   ".$_;
                #$special_char_lines{$count}=$line;
            }
        }
        my ($class,$surname,$firstname,$date) = split(/;/);
        # split firstname-field into single firstnames
        # split at 'space' and '-'
        my @firstnames=split(/[ ,-]/, $firstname);
        foreach my $first (@firstnames){
            if ($first=~/[^a-zA-Z\-]/) { 
                # continue with non-standard(~non-ascii) chars
                my $hit_count=0;   
                my $error_count=0; 
                foreach my $enc (@encodings_to_check){
                    my $conv = Text::Iconv->new($enc,"utf8");
                    my $first_utf8 = $conv->convert($first);

                    # check for positive hits (known, valid firstnames)
                    if (exists $firstnames_data{$enc}{$first}){
                        # remember hits
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count hits
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=$new;
                        $hit_count++;
                    }
                    # check for errors
                    if (exists $firstnames_errors{$enc}{$first}){
                        # remember errors
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count errors
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=$new;
                        $hit_count++;
                    }
                }
                # non-hits and non-errors (unknown firstnames) 
                if ($hit_count==0 and $error_count==0){
                    # remember unknown names
                    push @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} }, 
                           { first => "$first", 
                             line => "$_"};
                    # count unknown names
                    my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'};
                    my $new=$old+1;
                    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=$new;
                }
            }
        }
    }

    # calculate sum
    my $oldsum=0;
    foreach my $enc (@encodings_to_check){
        my $sum=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}+
	        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc}=$sum;
        if($sum > $oldsum){
            $encoding_check_results{$file}{'firstnames'}{'result'}=$enc;
        }
    }

    # save result in config hash
    $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED}=
        $encoding_check_results{$file}{'firstnames'}{'result'};
    return $encoding_check_results{$file}{'firstnames'}{'result'};
}



sub print_analyzed_encoding {
    my ($file) = @_;
    print "\nEncoding check result for:\n";
    print "   $file\n";

    # print valid firstnames
    if($Conf::log_level>=2){
    print "\nValid firstnames: ",
          "($encoding_check_results{$file}{'firstnames'}{'result'} ---> utf8)\n";
    print "==========================================================================\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} } ){
        printf  "%-20s %-12s %-20s\n",
                $item->{first},
                "--->",
                $item->{first_utf8};
    }
    print "--------------------------------------------------------------------------\n";
    }

    # print unknown firstnames
    print "\n";
    print "Unknown firstnames (Please report to info\@linuxmuster.net):\n";
    print "+------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} } ){
        printf  "| %-40s |\n",
                $item->{first},
    }
    print "+------------------------------------------+\n";

    #  print firstnames with errors
    print "\nFirstnames that should be an error (Please report the the School Office):\n";
    print "+---------------------------------------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} } ){
        printf  "| %-15s%-60s|\n",
                $item->{first_utf8},
                $item->{line};
        my $enc_result=$encoding_check_results{$file}{'firstnames'}{'result'};
        printf  "|          ---> %-60s|\n",$firstnames_errors{$enc_result}{ $item->{first} };
        print "+---------------------------------------------------------------------------+\n";
    }

    # print debug dump
    if($Conf::log_level>=3){
        print "Dump of \%encoding_check_results:\n";
        print Dumper(\%encoding_check_results);
    }

    # Print Result
    print "\n";
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "Tested Encodings:",
            "Hits",
            "Errors",
            "Sum";
    print "+---------------------+--------+--------+--------+\n";
    foreach my $enc (@encodings_to_check){
        printf  "| %-20s|%7s |%7s |%7s |\n",
                $enc,
                $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc},
                $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc},
   	        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc};
    }
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "none",
            $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'},
            "",
            "";
    print "+---------------------+--------+--------+--------+\n";
    print "$file:\n",
          "    File-Encoding is $encoding_check_results{$file}{'firstnames'}{'result'}\n"; 
    print "\n";
    close(DATAFILE);
}
