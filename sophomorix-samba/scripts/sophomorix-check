#!/usr/bin/perl -w
# This script (sophomorix-check) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@linuxmuster.net

# Bibliotheken
use strict;
#use Quota;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use List::MoreUtils qw(uniq);
use String::Approx 'amatch';
use String::Approx 'adist';
use Net::LDAP;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1; 
use JSON;
use File::Basename qw( basename
                       dirname
                     ); 
use Text::Iconv;
use Sophomorix::SophomorixBase qw(
                                 print_line
                                 print_title
                                 time_stamp_AD
                                 time_stamp_file
                                 unlock_sophomorix
                                 lock_sophomorix
                                 log_script_start
                                 log_script_end
                                 log_script_exit
                                 backup_amku_file
                                 get_passwd_charlist
                                 get_plain_password
                                 check_options
                                 config_sophomorix_read
                                 filelist_fetch
                                 remove_whitespace
                                 json_dump
                                 recode_utf8_to_ascii
                                 );
use Sophomorix::SophomorixSambaAD qw(
                                 AD_ou_add
                                 AD_bind_admin
                                 AD_unbind_admin
                                 AD_user_create
                                 AD_group_create
                                 AD_group_addmember
                                 AD_group_update
                                 AD_get_ou_tokened
                                 AD_get_name_tokened
                                 AD_dn_fetch_multivalue
                                 AD_get_AD
                                 AD_dns_get
                                 AD_object_search
                                 get_forbidden_logins
                                    );

my @arguments = @ARGV;

my $time_stamp_file=&time_stamp_file();
my $time_stamp_AD=&time_stamp_AD();
my $user_count=0;

my $school="";
my %users_file=();

# allowed numbers for days
my %convert_day = qw(
     1     01          01    01
     2     02          02    02
     3     03          03    03
     4     04          04    04
     5     05          05    05
     6     06          06    06
     7     07          07    07
     8     08          08    08
     9     09          09    09
     10    10          11    11
     12    12          13    13
     14    14          15    15
     16    16          17    17
     18    18          19    19
     20    20          21    21
     22    22          23    23
     24    24          25    25
     26    26          27    27
     28    28          29    29
     30    30          31    31
);

# allowed numbers for months
my %convert_month = qw(
     1     01          01    01
     2     02          02    02
     3     03          03    03
     4     04          04    04
     5     05          05    05
     6     06          06    06
     7     07          07    07
     8     08          08    08
     9     09          09    09
     10    10          11    11
     12    12
);




# encoding tests
my %firstnames_data=();
my %firstnames_errors=();
my %encoding_check_results=();
my @encodings_to_check=("utf8","ISO_8859-1");

my @loglines=();

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Variablen für Optionen
$Conf::log_level=1;
my $help=0;
my $info=0;
my $dump_files=0;
my $dump_AD=0;
my %Match=();
my $dump_matches=0;
my $json=0;
my $list_files=0;
my $lock=0;
my $unlock=0;
my $analyze_encoding="";
my $show_special_char_lines=0;
my $non_umlaut=0;
my @special_char_lines=();
my $follow="";

# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$Conf::log_level,
           "info|i" => \$info,
           "dump-files" => \$dump_files,
           "dump-AD" => \$dump_AD,
           "dump-matches" => \$dump_matches,
           "json|j+" => \$json,
           "list-files" => \$list_files,
           "lock" => \$lock,
           "analyze-encoding=s" => \$analyze_encoding,
           "follow=s" => \$follow,
           "unlock" => \$unlock,
           "show-special-char-lines" => \$show_special_char_lines,
           "non-umlaut|nonumlaut" => \$non_umlaut,
           "help|h" => \$help,
          );


# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

# --follow
my $follow_file="";
my $follow_line="";
if ($follow ne ""){
    ($follow_file,$follow_line)=split(/:/,$follow);
}

# Reading Configuration
my ($ldap,$root_dse) = &AD_bind_admin();
my $root_dns=&AD_dns_get($root_dse);
my %sophomorix_config=&config_sophomorix_read($ldap,$root_dse);
my @filelist=&filelist_fetch({filetype=>"users",
                              sophomorix_config=>\%sophomorix_config,
                            });

# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
sophomorix-check checks the configured user files and finds out which users should be added, updated, moved and killed


Options:
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info

  --list-files                     (list processed files and exit)
  --lock / --unlock

  --follow filename:linenumber     (show what happens to this line)

Analyze the encoding of a file:
  --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show Umlaut and other special chars
  --show-special-char-lines --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show special chars (not umlauts)
  --non-umlaut  --show-special-char-lines --analyze-encoding /path/to/students.csv

Usable encodings in school.conf:
   iconv -l

Dumping data:                     
  -ij / --info --json              (dump configuration)
  --dump-files -j                  (dump contents of user files)
  --dump-AD -j                     (dump AD data)
  --dump-matches -j                (dump matched users)

  -j / --json                      (dump as a nice json object)
  -jj / --json --json              (dump as a compact json object)
  -jjj / --json --json --json      (dump as a perl hash)


 
Please see the sophomorix-check(8) man pages for full documentation
');
   print "\n";
   exit;
}


# --unlock
if ($unlock==1) {
    &unlock_sophomorix();
    exit;
}


# --lock
if ($lock==1) {
    &lock_sophomorix("lock",0,@arguments);
    exit;
}


# --info
if ($info==1) {
    &json_dump({json => $json,
                jsoninfo => "CONFIG",
                jsoncomment => "The sophomorix configuration",
                hash_ref=>\%sophomorix_config,
               });
    print "\n";
    &print_title("Reading the following user files:");
    foreach my $file (@filelist){
        print "   * $file\n";
    }
    exit;
}


# --list-files
if ($list_files==1) {

       &print_title("Reading the following user files:");
       foreach my $file (@filelist){
           print "   * $file\n";
       }
       exit;
   }


# --analyze-encoding
# analyze one file
if ($analyze_encoding ne ""){
    if($Conf::log_level>=3){
        print "\n";
        print "Analyzing encoding\n";
    }
    &reading_firstnames();
    &reading_firstname_errors();
    my $enc=&analyze_encoding($analyze_encoding,$analyze_encoding);
    if ($show_special_char_lines==1){
        my $count=0;
	foreach my $line (@special_char_lines){
            my $conv = Text::Iconv->new($enc,"utf8");
            my $line_utf8 = $conv->convert($line);
            if ($non_umlaut==1){
                # äöüÄÖÜß works because its unicode
                if ($line_utf8=~/[^äöüÄÖÜßa-zA-Z0-9\-\.;_\/\s]/) { 
                    $count++;
                    print "$count)  $line_utf8\n";
                }
            } else {
                    $count++;
                    print "$count)  $line_utf8\n";
            }
        }
    }
    &print_analyzed_encoding($analyze_encoding);
    &log_script_exit("",1,1,0,@arguments);
}

&log_script_start(@arguments);


################################################################################
# Start
################################################################################

# ============================================================
# copy or filter files
# ============================================================
&Sophomorix::SophomorixBase::print_title("Copying/Filtering files to $DevelConf::path_conf_tmp");
foreach my  $user_file (@filelist){
    my $filename = basename($user_file);
    my $source=$user_file;
    my $targer_dir=
    my $target=
        $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'FILTERTARGET'};
    my $filter_script=
        $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'FILTERSCRIPT'};
    
    system("mkdir -p $DevelConf::path_conf_tmp");
    if ($filter_script eq "---"){
        print "   * Copying $filename\n";
        if($Conf::log_level>=2){
            print "cp $source\n  ---> $target\n";
        }
        system("cp $source $target");
    } elsif ($filter_script eq "ERROR_FILTERSCRIPT"){
        print "\nERROR: The configured Filter is not an executable script:\n";
        print "   <$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{FILTERSCRIPT_CONFIGURED}>\n";
        print "\n";
        exit;
    } else {
        # filter script is executable, when in config hash -> run it
        my $filter_script_filename = basename($filter_script);
        my $filter_log_file=$DevelConf::path_conf_tmp."/".$filename."_".$filter_script_filename.".log";
        print "   * Filtering $filename: $filter_script\n";
        print "     * Logging to: $filter_log_file\n";
        system("$filter_script > $filter_log_file  2>&1");
    } 
}


# ============================================================
# analyzing encoding of all filtered user files in tmp
# ============================================================
&reading_firstnames();
&reading_firstname_errors();
foreach my  $user_file (@filelist){
    my $filename = basename($user_file);
    my $user_file_tmp=$DevelConf::path_conf_tmp."/".$filename.".filter";
    # file in tmp    
    &analyze_encoding($user_file,$user_file_tmp);
}


# ============================================================
# reading and checking all filtered user files
# ============================================================
foreach my $user_file (@filelist){
    my $count=0;
    my $filename = basename($user_file);
    my $user_file_tmp=$DevelConf::path_conf_tmp."/".$filename.".filter";
    # fetching some config data
    $school=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'};

    # file in tmp    
    &print_title("Reading $user_file_tmp");
    my $enc_used=&get_encoding($filename);
    open(USERS,"$user_file_tmp") || 
         die "ERROR: $user_file_tmp not found!";  
    while(<USERS>){
        $count++;
        &analyze_user_line($_,$user_file,$user_file_tmp,
                           $filename,$school,$count,$enc_used);
    }
    close(USERS);
}


# --dump-files
if ($dump_files==1){
    &json_dump({json => $json,
                jsoninfo => "USERS",
                jsoncomment => "All users read from all user files",
                hash_ref=>\%users_file,
               });
}


# --follow
# show the line
if ($follow ne ""){
    my $identifier=$users_file{'file'}{$follow_file}{$follow_line}{'identifier_ascii'};
    if (not defined $identifier){
        print "   * Line $follow_line in file $follow_file contains no usable data\n";
    } else {
        print "   * LINE ORIG: $users_file{'identifier_ascii'}{$identifier}{LINE_OLD}\n";
        print "   * LINE UTF8: $users_file{'identifier_ascii'}{$identifier}{LINE_NEW}\n";
    }
}


# ============================================================
# asking AD for users
# ============================================================
&print_title("Asking the system for users ...");

# fetch system data
my ($ref_AD) = &AD_get_AD({ldap=>$ldap,
                           root_dse=>$root_dse,
                           root_dns=>$root_dns,
                           computers=>"FALSE",
                           rooms=>"FALSE",
                           examaccounts=>"TRUE",
                           users=>"TRUE",
                           dnszones=>"FALSE",
                           dnsnodes=>"FALSE",
             });
my %AD= %$ref_AD; 


# --dump-AD
if ($dump_AD==1){
    &json_dump({json => $json,
                jsoninfo => "SEARCH",
                jsoncomment => "AD Content",
                hash_ref=>\%AD,
              });
}


# ============================================================
# Walk thhrough all files and identifiers in %users_file
# ============================================================

# dynamic matching data ist contained in %Match
# reading user files populate these subhashes (file identifiers):
# $Match{'file_dynamic_identifiers_ascii'} or $users_file{'file_dynamic_identifiers_utf8'}
# and populated from AD by subs (AD identifiers): 
# $Match{'ad_dynamic_identifiers_ascii'} $Match{'ad_dynamic_identifiers_utf8'}


# no migration
#&populate_ad_dynamic_identifiers_utf8();

# migration
&populate_ad_dynamic_identifiers_ascii();

&find_migration_unid_matches();
&find_migration_ascii_matches();

# schleife erstellen, die abbricht wenn es nix mehr zu tun gibt
&find_migration_ascii_approx_matches(1);
&find_migration_ascii_approx_matches(2);
&find_migration_ascii_approx_matches(3);
&find_migration_ascii_approx_matches(4);
# marriage, birthdate, ... and such matches

# check if this is so:
# track approx number with matches 

# --dump-matches
if ($dump_matches==1){
    &json_dump({json => $json,
                jsoninfo => "MATCH",
                jsoncomment => "File user -> AD matches",
                hash_ref=>\%Match,
              });
}




# write into files
#   - go through matches lines in line order
#####################################
#   - check for each matched line:
#     - compare ldap entries, class and school
#      - write to:
#        - sophomorix.nochange -> do nothing, just for information
#        - sophomorix.update   -> update ldap-data and status (+times, if not current)
#        - sophomorix.move     -> move to another class or school
#####################################
#   - unmatched line:
#     - new user: write sophomorix.add
#####################################
#   - unmatched user in ldap:
#     - sophomorix.update mit status und time
#     - sophomorix.kill (if status and times say so)


my $update=$DevelConf::path_result."/sophomorix.update";
open (UPDATE, ">$update");
my $move=$DevelConf::path_result."/sophomorix.move";
open (MOVE, ">$move");
my $kill=$DevelConf::path_result."/sophomorix.kill";
open (KILL, ">$kill");
my $nochange=$DevelConf::path_result."/sophomorix.nochange";
open (NOCHANGE, ">$nochange");

foreach my $line_new ( @{ $Match{'lines'} } ){
    if (defined $Match{'action'}{$line_new}{'sAMAccountName'}){
        my $update=&write_update_file($line_new);
        my $move=&write_move_file($line_new);
        my $kill=&write_kill_file($line_new);
        my $sum=$update+$move+$kill;
        if ($sum==0){
            print NOCHANGE "$line_new\n";
        }
    } else {
        &write_add_file($line_new);
    }
}

close(UPDATE);
close(MOVE);
close(KILL);
close(NOCHANGE);



&AD_unbind_admin($ldap);

&log_script_end(@arguments);



################################################################################
# Sub
################################################################################

# writing lines into files
################################################################################


sub write_add_file {
    my ($line_new)=@_;
    my $add=0;
    if($Conf::log_level>=2){
        print "$line_new\n";
        print "   * not matched to any sAMAccountName\n";
    }


    return $add;
}

sub write_update_file {
    my ($line_new)=@_;
    my $sam=$Match{'action'}{$line_new}{'sAMAccountName'};
    my $unid;
    my $surname_ascii;
    my $firstname_ascii;
    my $surname_utf8;
    my $firstname_utf8;
    my $birthdate;
    my $update=0;
    if($Conf::log_level>=2){
        print "$line_new\n";
        print "   * matched to: $sam --> $Match{'action'}{$line_new}{'MATCH_SUB'}\n";
    }

    # unid
    if ( ($Match{'action'}{$line_new}{'unid'} eq $AD{'sam'}{$sam}{'sophomorixUnid'}) or
         ($Match{'action'}{$line_new}{'unid'} eq "" and $AD{'sam'}{$sam}{'sophomorixUnid'} eq "---") ){
        # no update
        $unid="---";
    } else {
        # update
        $update++;
        $unid=$Match{'action'}{$line_new}{'unid'};
    }

    # surname_ascii
    if ( ($Match{'action'}{$line_new}{'surname_ascii'} eq $AD{'sam'}{$sam}{'sophomorixSurnameASCII'})){
        # no update
        $surname_ascii="---";
    } else {
        # update
        $update++;
        $surname_ascii=$Match{'action'}{$line_new}{'surname_ascii'};
    }

    # firstname_ascii
    if ( ($Match{'action'}{$line_new}{'firstname_ascii'} eq $AD{'sam'}{$sam}{'sophomorixFirstnameASCII'} )){
        # no update
        $firstname_ascii="---";
    } else {
        # update
        $update++;
        $firstname_ascii=$Match{'action'}{$line_new}{'firstname_ascii'};
    }


    # firstname_utf8 and surname_utf8
    if ( ($Match{'action'}{$line_new}{'firstname_utf8'} ne $AD{'sam'}{$sam}{'givenName'}) or
         ($Match{'action'}{$line_new}{'surname_utf8'} ne $AD{'sam'}{$sam}{'sn'}) ){
        $update++;
        $firstname_utf8=$Match{'action'}{$line_new}{'firstname_utf8'};
        $surname_utf8=$Match{'action'}{$line_new}{'surname_utf8'};
    } else {
        # no update
        $firstname_utf8="---";
        $surname_utf8="---";
    }

    # # surname_utf8
    # if ( ($Match{'action'}{$line_new}{'surname_utf8'} eq $AD{'sam'}{$sam}{'sn'})){
    #     # no update
    #     $surname_utf8="---";
    # } else {
    #     # update
    #     $update++;
    #     $surname_utf8=$Match{'action'}{$line_new}{'surname_utf8'};
    # }

    # # firstname_utf8
    # if ( ($Match{'action'}{$line_new}{'firstname_utf8'} eq $AD{'sam'}{$sam}{'givenName'} )){
    #     # no update
    #     $firstname_utf8="---";
    # } else {
    #     # update
    #     $update++;
    #     $firstname_utf8=$Match{'action'}{$line_new}{'firstname_utf8'};
    # }

    # birthdate
    if ( ($Match{'action'}{$line_new}{'birthdate'} eq $AD{'sam'}{$sam}{'sophomorixBirthdate'} )){
        # no update
        $birthdate="---";
    } else {
        # update
        $update++;
        $birthdate=$Match{'action'}{$line_new}{'birthdate'};
    }

    # create line for sophomorix.update
    my $update_line=$sam."::".$unid."::".$surname_ascii."::".$firstname_ascii.
       "::".$birthdate."::".$surname_utf8."::".$firstname_utf8."::\n";
    if ($update > 0){
        print "sophomorix.update: $update_line";
        print UPDATE $update_line;
    }
    return $update;
}



sub write_move_file {
    my ($line_new)=@_;
    my $sam=$Match{'action'}{$line_new}{'sAMAccountName'};
    my $move=0;


    return $move;
}



sub write_kill_file {
    my ($line_new)=@_;
    my $sam=$Match{'action'}{$line_new}{'sAMAccountName'};
    my $kill=0;

    return $kill;
}





# UTF8 match
################################################################################
sub populate_ad_dynamic_identifiers_utf8 {
    foreach my $identifier_utf8 (keys %{$AD{'lookup'}{'user_by_identifier_utf8'}} ) { 
        $Match{'ad_dynamic_identifiers_utf8'}{$identifier_utf8}="ad, not matched";
    } 
}



# Migration match
################################################################################
# call this in the end of all matches ??????????????????????ßßß
sub show_dynamic_identifiers_ascii {
    my $file_count=0;
    my $ad_count=0;
    my @file_ids=();
    my @ad_ids=();
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        push @file_ids, $identifier_ascii;
        $file_count++;
    } 
    foreach my $identifier_ascii (keys %{$Match{'ad_dynamic_identifiers_ascii'}} ) {
        push @ad_ids, $identifier_ascii;
        $ad_count++;
    }
    my $diff=$ad_count-$file_count;
    &print_title("$file_count users in files to be matched with $ad_count in AD (Diff: $diff)");
    if ($file_count==0 or $ad_count==0){
	return 0;
    } else {
        if($Conf::log_level>=2){
	    @file_ids= sort @file_ids;
            print "file_dynamic_identifiers_ascii:\n";
            foreach my $id (@file_ids){
                print "   * $id (in files)\n";
            }   
	    @ad_ids = sort @ad_ids;
            print "ad_dynamic_identifiers_ascii:\n";
            foreach my $id (@ad_ids){
                my $status=
                print "   * $id ($AD{'lookup'}{'user_by_identifier_ascii'}{$id} in AD,",
                      " status $AD{'lookup'}{'status_by_identifier_ascii'}{$id})\n";
            }    
        }
        return 1;
    }
}



sub populate_ad_dynamic_identifiers_ascii {
    foreach my $identifier_ascii (keys %{$AD{'lookup'}{'user_by_identifier_ascii'}} ) { 
        $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii}="ad, not matched";
    } 
}



sub find_migration_ascii_approx_matches {
    my ($max_edit_distance) = @_;
    my $run="approx_".$max_edit_distance."_run";
    print "\n";
    &print_title("Migration approx matching (max. edit distance $max_edit_distance)");
    my $ret=&show_dynamic_identifiers_ascii();
    if ($ret==0){
        print "---> Nothing to do anymore\n";
	    return 0;
    }
    my $line_count=0;
    my $matched_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        $line_count++;
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        print " $filename:",
              "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
              "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
              "$identifier_ascii\n";
        my $count=0;
        foreach my $identifier_ascii_ad ( keys %{ $Match{'ad_dynamic_identifiers_ascii'} } ){
            $count++;
            my $edit_distance=&edit_distance($identifier_ascii,$identifier_ascii_ad);
            if($Conf::log_level>=3){
                print "   * $identifier_ascii <---> $identifier_ascii_ad ($count)\n";
                print "      * $edit_distance (Edit distance)\n";
            }
            if ($edit_distance <= $max_edit_distance){
                # APPROX MATCH
                my $sam=$AD{'lookup'}{'user_by_identifier_ascii'}{$identifier_ascii_ad};
                print "   * APPROXMATCH($edit_distance): $identifier_ascii_ad\n";
                delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii_ad};
                # save match to delete this match from list
                $Match{'file_approx_match'}{$run}{$identifier_ascii}=$edit_distance;
                # remove the approx matches from the list
                delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};

                # save to write later
                my $sub=(caller(0))[3];
                my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
                $Match{'action'}{$line_new}{'sAMAccountName'}=$sam;
                $Match{'action'}{$line_new}{'MATCH_SUB'}="$sub $max_edit_distance";
                $Match{'action'}{$line_new}{'status'}=
                    $AD{'lookup'}{'status_by_identifier_ascii'}{$identifier_ascii};

            }
        }
    }
    &print_title("Migration approx matching ($line_count tested)");
}



sub find_migration_ascii_matches {
    print "\n";
    &print_title("Migration matching ascii-to-utf8");
    &show_dynamic_identifiers_ascii();
    my $line_count=0;
    my $matched_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        $line_count++;
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        if ( exists $AD{'lookup'}{'user_by_identifier_ascii'}{$identifier_ascii} ){
            # MATCH
            my $sam=$AD{'lookup'}{'user_by_identifier_ascii'}{$identifier_ascii};
            if($Conf::log_level>=2){
                print "    MATCH: $identifier_ascii to $sam\n";
            }

            # save to write later
            my $sub=(caller(0))[3];
            $Match{'file'}{$filename}{$identifier_ascii}=$sam;
            my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
            $Match{'action'}{$line_new}{'sAMAccountName'}=$sam;
            $Match{'action'}{$line_new}{'MATCH_SUB'}="$sub";
            $Match{'action'}{$line_new}{'status'}=
                $AD{'lookup'}{'status_by_identifier_ascii'}{$identifier_ascii};

            # remove from ad_to_be_matched
            delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii};
            delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};
            $matched_count++;
        } else {
            # NO MATCH
            print " $filename:",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                  "$identifier_ascii\n";
            print "   --> No exact match for $identifier_ascii\n";
            $Match{'find_migration_ascii_matches'}{$identifier_ascii}="no exact identifier match possible";
            $not_matched_count++;
        }
    }
    &print_title("ascii--to-utf8-Matching $line_count lines: $matched_count matched, $not_matched_count unmatched");
}



sub find_migration_unid_matches {
    print "\n";
    &print_title("unidMatching lines to accounts:");
    &show_dynamic_identifiers_ascii();
    my $line_count=0;
    my $matched_count=0;
    my $no_unid_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        $line_count++;
        if ($users_file{'identifier_ascii'}{$identifier_ascii}{UNID} ne ""){
            # finding a unid match 
            if ( exists $AD{'lookup'}{'user_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}} ){
                # MATCH
                my $sam=$AD{'lookup'}{'user_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}};
                my $role=$AD{'lookup'}{'role_by_user'}{$sam};
                # fetch the identifier from AD with same unid
                my $identifier_ascii_from_AD=
		    $AD{'lookup'}{'identifier_ascii_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}};
                if($Conf::log_level>=2){
                    print " $filename:",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                          "$identifier_ascii\n";
	            print "  --> unidMATCH: $sam --> ",
                          "$identifier_ascii_from_AD\n";
                }
                $matched_count++;
                # remove from dynamic hashes
                delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii_from_AD};
                delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};

                # save to write later
                my $sub=(caller(0))[3];
                $Match{'file'}{$filename}{$identifier_ascii}=$sam;
                my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
                $Match{'action'}{$line_new}{'sAMAccountName'}=$sam;
                $Match{'action'}{$line_new}{'MATCH_SUB'}="$sub";
                $Match{'action'}{$line_new}{'status'}=
                    $AD{'lookup'}{'status_by_identifier_ascii'}{$identifier_ascii};

            } else {
                # NO MATCH
                $Match{'find_migration_unid_matches'}{$identifier_ascii}="no unid match";
                $not_matched_count++;
                print " $filename:",
                      "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                      "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                      "$identifier_ascii\n";
                print "   --> Unid $users_file{'identifier_ascii'}{$identifier_ascii}{UNID}",
                      " not found in AD\n";
            }
        } else {
            $no_unid_count++;
            $Match{'find_migration_unid_matches'}{$identifier_ascii}="no unid, no match possible";
        }
    }
    &print_title("unidMatching $line_count lines: $matched_count matched, $not_matched_count unmatched, $no_unid_count without unid");
}



# APPROX stuff
################################################################################
sub edit_distance {
    my ($string1,$string2)=@_;
    my $string;
    my $pattern;
    # the shorter string is the pattern to avoid negative edit distances    
    if (length($string1) < length($string2)){
        $string=$string2;
        $pattern=$string1;
    } else {
	$string=$string1;
        $pattern=$string2;
    }
    my $edit_distance=adist($pattern,$string);
    return $edit_distance;
}



# checking stuff
################################################################################
sub analyze_user_line {
    my ($line,$file_abs,$file_abs_tmp,$filename,$school,$count,$enc_used) = @_;
    if (/^#/ or /^\s*$/){
        return 0;
    } else {
        chomp($line);
        my ($class_raw,
            $last_raw,
            $first_raw,
            $birthdate_raw,
            $field5,
           )=split(/;/,$line);

        my $class=&check_class($class_raw);
        my $first=&check_first($first_raw);
        my $last=&check_last($last_raw);
        my $birthdate=&check_birthdate($birthdate_raw);
        my $unid="";
        my $login="";
        my $field5_key=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{FIELD5};
        if ($field5_key eq "LOGIN"){
            $login=&check_login($field5);
        } elsif ($field5_key eq "UNID"){
            $unid=&check_unid($field5);
        }


        # converting names to utf8 and then to ascii
        my $conv = Text::Iconv->new($enc_used,"utf8");
        my $first_utf8 = $conv->convert($first);
        my $last_utf8 = $conv->convert($last);
        my $first_ascii =&recode_utf8_to_ascii($first_utf8);
        my $last_ascii =&recode_utf8_to_ascii($last_utf8);
        # identifier
        my $identifier_utf8=join(";", ($last_utf8,$first_utf8,$birthdate));
        my $identifier_ascii=join(";", ($last_ascii,$first_ascii,$birthdate));
        # corrected line
        my $line_new=join(";", ($class,$last_utf8,$first_utf8,$birthdate,$unid));

        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_OLD}=$line;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW}=$line_new;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_ASCII}=$first_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_UTF8}=$first_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_ASCII}=$last_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_UTF8}=$last_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{BIRTHDATE}=$birthdate;
        $users_file{'identifier_ascii'}{$identifier_ascii}{CLASS}=$class;
        $users_file{'identifier_ascii'}{$identifier_ascii}{UNID}=$unid;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LOGIN}=$login;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE}=$filename;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_ASCII}=$identifier_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_UTF8}=$identifier_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}=$count;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE_ABS}=$file_abs;

        # add here more stuff to create sophomorix.add, ...
        $users_file{'identifier_ascii'}{$identifier_ascii}{ROLE}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{RT_sophomorixRole};
        #$users_file{'identifier_ascii'}{$identifier_ascii}{OU}=
        #    $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{OU};
        $users_file{'identifier_ascii'}{$identifier_ascii}{SCHOOL}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{SCHOOL};

        # identifier list
        #push @{ $users_file{'file'}{$filename}{'identifier_list_ascii'} }, $identifier_ascii;
        #push @{ $users_file{'file'}{$filename}{'identifier_list_utf8'} }, $identifier_utf8;

        # identifier hash
        $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii}="files, not matched";
        $Match{'file_dynamic_identifiers_utf8'}{$identifier_utf8}="files, not matched";

        # file -> line
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_ASCII'}=$identifier_ascii;
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_UTF8'}=$identifier_utf8;

        # save for action 
        $Match{'action'}{$line_new}{'identifier_ascii'}=$identifier_ascii;
        $Match{'action'}{$line_new}{'school'}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{SCHOOL};
	$Match{'action'}{$line_new}{'birthdate'}=$birthdate;
	$Match{'action'}{$line_new}{'class'}=$class;
	$Match{'action'}{$line_new}{'file'}=$filename;
	$Match{'action'}{$line_new}{'firstname_ascii'}=$first_ascii;
	$Match{'action'}{$line_new}{'surname_ascii'}=$last_ascii;
	$Match{'action'}{$line_new}{'firstname_utf8'}=$first_utf8;
	$Match{'action'}{$line_new}{'surname_utf8'}=$last_utf8;
	$Match{'action'}{$line_new}{'line_count'}=$count;
        $Match{'action'}{$line_new}{'role'}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{RT_sophomorixRole};
	$Match{'action'}{$line_new}{'unid'}=$unid;

         # list of lines
         push @{ $Match{'lines'} }, $line_new;
    }
}



sub check_class {
    my ($class)=@_;
    $class=&remove_whitespace($class);
    # convert to small letters
    $class=~tr/A-Z/a-z/; 
    # sternchenklassen filtern ?????
    # klassen filtern ?????
    $class=~s/\//$DevelConf::replace_slash_with/g;

    if ($class eq "lehrer" or 
        $class eq "Lehrer"
       ){
        $class=$DevelConf::teacher;
    }
    return $class;
}



sub check_first {
    my ($first)=@_;
    $first=&remove_whitespace($first);
    return $first;
}



sub check_last {
    my ($last)=@_;
    $last=&remove_whitespace($last);
    return $last;
}



sub check_birthdate {
    my ($birthdate)=@_;
    $birthdate=&remove_whitespace($birthdate);
    my $dot_count=$birthdate=~tr/\.//;
    if ($dot_count==2){
        if($Conf::log_level>=3){
            print " ... $dot_count dots in date found ... OK\n";
	}
    } elsif ($birthdate eq ""){
        if($Conf::log_level>=3){
            print " ... Date is empty, Line not corrupted ...\n";
	}
    } else {
	#$datum_korrupt=1;
        print " ... $dot_count dots in date found ... ERROR\n";
	#$datum_korrupt_anzahl++;
          
        # Eintrag in report.admin
        #push (@admin_list_corrupt, "Corrupted Line (" , $punkte_anzahl ,
        #                  " dots in date):\n" , $_ , "\n\n");
        # Set tag for Abbruch
        #$tag = "0"  
    }

    my ($day,$month,$year)=split(/\./,$birthdate);

    $day=$convert_day{$day};
    $month=$convert_month{$month};

    # Instead of undefined use empty string
    # this avoids errors
    if (not defined $day){
        $day="";
    }
    if (not defined $month){
        $month="";
    }
    if (not defined $year){
        $year="";
    }

    my $birthdate_ok = join(".",($day,$month,$year));
    return $birthdate_ok;
}



sub check_unid {
    my ($unid)=@_;
    $unid=&remove_whitespace($unid);
    return $unid;
}



sub check_login {
    my ($login)=@_;
    $login=&remove_whitespace($login);
    return $login;
}



# Encoding stuff
################################################################################
sub reading_firstnames {
    my @datafiles=("firstnames.utf8.txt", 
                   "firstnames.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($first,$first_new) = split(/:/);
            $firstnames_data{$enc}{$first}=0;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for encoding: $enc\n";
        }
        close(DATAFILE);
    }
}



sub reading_firstname_errors {
    my @datafiles=("firstname_errors.utf8.txt", 
                   "firstname_errors.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($error,$message) = split(/:/);
            $message=~s/^\s+ //g;
            $firstnames_errors{$enc}{$error}=$message;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for errors: $enc\n";
        }
        close(DATAFILE);
    }
}



sub get_encoding {
    my ($filename)=@_;
    my $enc_used;
    my $enc=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING};
    my $enc_force=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_FORCE};
    my $enc_checked=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED};
    print "   * ENCODING:          $enc\n";
    print "   * ENCODING_FORCE:    $enc_force\n";
    print "   * ENCODING_CHECKED:  $enc_checked\n";

    # misconfigured *.school.conf: exit
    if ($enc eq "ERROR_ENCODING"){
        print "   * Misconfigured ENCODING in configuration file, see \"iconv --list\"\n";
        exit;
    }   
    if ($enc_force eq "ERROR_ENCODING_FORCE"){
        print "   * Misconfigured ENCODING_FORCE in configuration file\n";
        exit;
    }   
 
    # auto setting
    if ($enc eq "auto" and $enc_force eq "no"){
        # auto
        if ($enc_checked eq "unknown"){
            print "   * ENCODING could not be checked automatically\n";
            print "   * Set ENCODING to the desired value and ENCODING_FORCE to \"yes\"\n";
            exit;
        }
        $enc_used=$enc_checked;
    } elsif ($enc ne "auto" and $enc_force eq "no"){
        # auto mismatch configure
        print "   * Misconfigured ENCODING in configuration file and ENCODING_CHECKED do not match\n";
        print "   * Set ENCODING_FORCE to \"yes\" if you know better than sophomorix\n";
        exit;
    } elsif ($enc ne "auto" and $enc_force eq "yes"){
        $enc_used=$enc;
    }

    print "           ---> Using:  $enc_used\n";
    return $enc_used;
}



sub analyze_encoding {
    my ($file,$file_tmp) = @_;
    # $file ist for printout anh path in config hash only
    # $file_tmp will be analyzed
    my $filename = basename($file);
    my $filename_tmp = basename($file_tmp);
    # set all result counters to 0
    foreach my $enc (@encodings_to_check){
        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=0;
        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=0;
    }
    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'count_errors'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'result'}="unknown";

    # start to analyze file_tmp
    &Sophomorix::SophomorixBase::print_title("Encode-analyze $filename_tmp");
    open(DATAFILE, "$file_tmp") || 
         die "Fehler: $! $file_tmp not found!"; 
    my $count=0;
    while (<DATAFILE>){
        $count++;
        chomp();
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }

        ####################################
        if ($show_special_char_lines==1){
            if ($_=~/[^a-zA-Z0-9\-\.;_\/\s]/) { 
                push @special_char_lines, "Line ".$count."   ".$_;
                #$special_char_lines{$count}=$line;
            }
        }
        my ($class,$surname,$firstname,$date) = split(/;/);
        # split firstname-field into single firstnames
        # split at 'space' and '-'
        my @firstnames=split(/[ ,-]/, $firstname);
        foreach my $first (@firstnames){
            if ($first=~/[^a-zA-Z\-]/) { 
                # continue with non-standard(~non-ascii) chars
                my $hit_count=0;   
                my $error_count=0; 
                foreach my $enc (@encodings_to_check){
                    my $conv = Text::Iconv->new($enc,"utf8");
                    my $first_utf8 = $conv->convert($first);

                    # check for positive hits (known, valid firstnames)
                    if (exists $firstnames_data{$enc}{$first}){
                        # remember hits
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count hits
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=$new;
                        $hit_count++;
                    }
                    # check for errors
                    if (exists $firstnames_errors{$enc}{$first}){
                        # remember errors
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count errors
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=$new;
                        $hit_count++;
                    }
                }
                # non-hits and non-errors (unknown firstnames) 
                if ($hit_count==0 and $error_count==0){
                    # remember unknown names
                    push @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} }, 
                           { first => "$first", 
                             line => "$_"};
                    # count unknown names
                    my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'};
                    my $new=$old+1;
                    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=$new;
                }
            }
        }
    }

    # calculate sum
    my $oldsum=0;
    foreach my $enc (@encodings_to_check){
        my $sum=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}+
	        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc}=$sum;
        if($sum > $oldsum){
            $encoding_check_results{$file}{'firstnames'}{'result'}=$enc;
        }
    }
    # save result in config hash
    $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED}=
        $encoding_check_results{$file}{'firstnames'}{'result'};
    if($Conf::log_level>=2){
        print "$file_tmp --> $encoding_check_results{$file}{'firstnames'}{'result'}\n";
    }
    return $encoding_check_results{$file}{'firstnames'}{'result'};
}



sub print_analyzed_encoding {
    my ($file) = @_;
    print "\nEncoding check result for:\n";
    print "   $file\n";

    # print valid firstnames
    if($Conf::log_level>=2){
    print "\nValid firstnames: ",
          "($encoding_check_results{$file}{'firstnames'}{'result'} ---> utf8)\n";
    print "==========================================================================\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} } ){
        printf  "%-20s %-12s %-20s\n",
                $item->{first},
                "--->",
                $item->{first_utf8};
    }
    print "--------------------------------------------------------------------------\n";
    }

    # print unknown firstnames
    print "\n";
    print "Unknown firstnames (Please report to info\@linuxmuster.net):\n";
    print "+------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} } ){
        printf  "| %-40s |\n",
                $item->{first},
    }
    print "+------------------------------------------+\n";

    #  print firstnames with errors
    print "\nFirstnames that should be an error (Please report the the School Office):\n";
    print "+---------------------------------------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} } ){
        printf  "| %-15s%-60s|\n",
                $item->{first_utf8},
                $item->{line};
        my $enc_result=$encoding_check_results{$file}{'firstnames'}{'result'};
        printf  "|          ---> %-60s|\n",$firstnames_errors{$enc_result}{ $item->{first} };
        print "+---------------------------------------------------------------------------+\n";
    }

    # print debug dump
    if($Conf::log_level>=3){
        print "Dump of \%encoding_check_results:\n";
        print Dumper(\%encoding_check_results);
    }

    # Print Result
    print "S\n";
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "Tested Encodings:",
            "Hits",
            "Errors",
            "Sum";
    print "+---------------------+--------+--------+--------+\n";
    foreach my $enc (@encodings_to_check){
        printf  "| %-20s|%7s |%7s |%7s |\n",
                $enc,
                $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc},
                $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc},
   	        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc};
    }
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "none",
            $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'},
            "",
            "";
    print "+---------------------+--------+--------+--------+\n";
    print "$file:\n",
          "    File-Encoding is $encoding_check_results{$file}{'firstnames'}{'result'}\n"; 
    print "\n";
    close(DATAFILE);
}
