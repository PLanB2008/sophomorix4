#!/usr/bin/perl -w
# This script (sophomorix-check) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@linuxmuster.net

# modules
use strict;
#use Quota;
use Getopt::Long;
#use Time::localtime;
use Time::Local;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use List::MoreUtils qw(uniq);
use String::Approx 'amatch';
use String::Approx 'adist';
use Net::LDAP;
use JSON;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1; 
use File::Basename qw( basename
                       dirname
                     ); 
use Text::Iconv;
use Sophomorix::SophomorixBase qw(
                                 print_line
                                 print_title
                                 time_stamp_AD
                                 time_stamp_file
                                 ymdhms_to_epoch
                                 unlock_sophomorix
                                 lock_sophomorix
                                 log_script_start
                                 log_script_end
                                 log_script_exit
                                 get_login_avoid
                                 create_test_login
                                 backup_auk_file
                                 get_passwd_charlist
                                 get_plain_password
                                 check_options
                                 config_sophomorix_read
                                 result_sophomorix_init
                                 result_sophomorix_add
                                 result_sophomorix_add_summary
                                 result_sophomorix_check_exit
                                 result_sophomorix_print
                                 filelist_fetch
                                 remove_whitespace
                                 json_dump
                                 recode_utf8_to_ascii
                                 );
use Sophomorix::SophomorixSambaAD qw(
                                 AD_school_create
                                 AD_bind_admin
                                 AD_unbind_admin
                                 AD_user_create
                                 AD_group_create
                                 AD_group_addmember
                                 AD_group_update
                                 AD_get_schoolname
                                 AD_get_name_tokened
                                 AD_dn_fetch_multivalue
                                 AD_get_AD
                                 AD_get_AD_for_check
                                 AD_dns_get
                                 AD_object_search
                                    );

my @arguments = @ARGV;

my $time_stamp_file=&time_stamp_file();
my $time_stamp_AD=&time_stamp_AD();
my $time_stamp_epoch=time;
my $user_count=0;

my $school="";
my %users_file=();
my %unid_seen=();

# allowed numbers for days
my %convert_day = qw(
     1     01          01    01
     2     02          02    02
     3     03          03    03
     4     04          04    04
     5     05          05    05
     6     06          06    06
     7     07          07    07
     8     08          08    08
     9     09          09    09
     10    10          11    11
     12    12          13    13
     14    14          15    15
     16    16          17    17
     18    18          19    19
     20    20          21    21
     22    22          23    23
     24    24          25    25
     26    26          27    27
     28    28          29    29
     30    30          31    31
);

# allowed numbers for months
my %convert_month = qw(
     1     01          01    01
     2     02          02    02
     3     03          03    03
     4     04          04    04
     5     05          05    05
     6     06          06    06
     7     07          07    07
     8     08          08    08
     9     09          09    09
     10    10          11    11
     12    12
);

# allowed numbers for years
my %convert_year = qw(
     1     2001          01    2001
     2     2002          02    2002
     3     2003          03    2003
     4     2004          04    2004
     5     2005          05    2005
     6     2006          06    2006
     7     2007          07    2007
     8     2008          08    2008
     9     2009          09    2009
     10    2010          11    2011
     12    2012          13    2013
     14    2014          15    2015
     16    2016          17    2017
     18    2018          19    2019
     20    2020          21    2021
     22    2022          23    2023
     24    2024          25    2025
     26    2026          27    2027
     28    2028          29    2029
     30    1930          31    1931
     32    1932          33    1933
     34    1934          35    1935
     36    1936          37    1937
     38    1938          39    1939
     40    1940          41    1941
     42    1942          43    1943
     44    1944          45    1945
     46    1946          47    1947
     48    1948          49    1949
     50    1950          51    1951
     52    1952          53    1953
     54    1954          55    1955
     56    1956          57    1957
     58    1958          59    1959
     60    1960          61    1961
     62    1962          63    1963
     64    1964          65    1965
     66    1966          67    1967
     68    1968          69    1969
     70    1970          71    1971
     72    1972          73    1973
     74    1974          75    1975
     76    1976          77    1977
     78    1978          79    1979
     80    1980          81    1981
     82    1982          83    1983
     84    1984          85    1985
     86    1986          87    1987
     88    1988          89    1989
     90    1990          91    1991
     92    1992          93    1993
     94    1994          95    1995
     96    1996          97    1997
     98    1998          99    1999
);
for( my $year = 1930 ; $year < 2029 ; $year++) {
    $convert_year{$year}=$year;
}


# encoding tests
my %firstnames_data=();
my %firstnames_errors=();
my %lastnames_data=();
my %lastnames_errors=();
my %encoding_check_results=();
my @encodings_to_check=("UTF8","ISO_8859-1");

my @loglines=();

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Variablen für Optionen
$Conf::log_level=1;
my $help=0;
my $info=0;
my $json=0;
my %Match=();

my $dump_matches=0;
my $dump_files=0;
my $dump_AD=0;
my $dump_login_avoid=0;

my $list_files=0;
my $lock=0;
my $unlock=0;
my $analyze_encoding="";
my $show_special_char_lines=0;
my $non_umlaut=0;
my @special_char_lines=();
my $follow="";
my @injectlines=(); # list of injected lines

# Parsen der Optionen
my $testopt=GetOptions(
           "help|h" => \$help,
           "info|i" => \$info,
           "json|j+" => \$json,
           "verbose|v+" => \$Conf::log_level,
           "lock" => \$lock,
           "unlock" => \$unlock,
           "dump-files" => \$dump_files,
           "dump-AD" => \$dump_AD,
           "dump-login-avoid" => \$dump_login_avoid,
           "dump-matches" => \$dump_matches,
           "list-files" => \$list_files,
           "analyze-encoding=s" => \$analyze_encoding,
           "follow=s" => \$follow,
           "injectline=s" => \@injectlines,
           "show-special-char-lines" => \$show_special_char_lines,
           "non-umlaut|nonumlaut" => \$non_umlaut,
          );


my %sophomorix_result=&result_sophomorix_init("sophomorix-check");
# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt,\%sophomorix_result,$json);

# --follow
my $follow_file="";
my $follow_line="";
if ($follow ne ""){
    ($follow_file,$follow_line)=split(/:/,$follow);
}

# Reading Configuration
my ($ldap,$root_dse) = &AD_bind_admin(\@arguments,\%sophomorix_result,$json);
my $root_dns=&AD_dns_get($root_dse);
my %sophomorix_config=&config_sophomorix_read($ldap,$root_dse,\%sophomorix_result);
my @filelist=&filelist_fetch({filetype=>"users",
                              sophomorix_config=>\%sophomorix_config,
                            });
my @class_filelist=&filelist_fetch({filetype=>"classes",
                                    sophomorix_config=>\%sophomorix_config,
                                  });

# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
sophomorix-check checks the configured user files and finds out which users should be added, updated, moved and killed


Options:
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info

  --list-files                     (list processed files and exit)
  --lock / --unlock

  --follow filename:linenumber     (show what happens to this line)

Analyze the encoding of a file:
  --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show Umlaut and other special chars
  --show-special-char-lines --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show special chars (not umlauts)
  --non-umlaut  --show-special-char-lines --analyze-encoding /path/to/students.csv

Usable encodings in school.conf:
   iconv -l

Dumping data:                     
  -ij / --info --json              (dump configuration)
  --dump-files -j                  (dump contents of user files)
  --dump-AD -j                     (dump AD data)
  --dump-login-avoid -j            (dump historic data from log files)
  --dump-matches -j                (dump matched users)

  -j / --json                      (dump as a nice json object)
  -jj / --json --json              (dump as a compact json object)
  -jjj / --json --json --json      (dump as a perl hash)

Injecting lines (repeat the option to inject multiple lines):                     
  --injectline "teachers.csv:7a;Meier;Richard;23.09.1996;mue999"
  --injectline "bsz.students.csv:7b;Schmid;Richard;26.04.1995;"
 
Please see the sophomorix-check(8) man pages for full documentation
');
   print "\n";
   exit;
}


# --unlock
if ($unlock==1) {
    &unlock_sophomorix();
    exit;
}


# --lock
if ($lock==1) {
    &lock_sophomorix("lock",0,\@arguments);
    exit;
}


# --info
if ($info==1) {
    &json_dump({json => $json,
                jsoninfo => "CONFIG",
                jsoncomment => "The sophomorix configuration",
                log_level => $Conf::log_level,
                hash_ref=>\%sophomorix_config,
                sophomorix_config=>\%sophomorix_config,
               });
    print "\n";
    &print_title("Reading the following user files:");
    foreach my $file (@filelist){
        print "   * $file\n";
    }
    foreach my $file (@class_filelist){
        print "   * $file\n";
    }
    exit;
}


# --list-files
if ($list_files==1) {
    &print_title("Reading the following user files:");
    foreach my $file (@filelist){
        print "   * $file\n";
    }
    foreach my $file (@class_filelist){
        print "   * $file\n";
    }
    exit;
}


&result_sophomorix_check_exit(\%sophomorix_result,\%sophomorix_config,$json);
&log_script_start(\@arguments,\%sophomorix_result);

# --analyze-encoding
# analyze one file
if ($analyze_encoding ne ""){
    if($Conf::log_level>=3){
        print "\n";
        print "Analyzing encoding\n";
    }
    &reading_firstnames();
    &reading_firstname_errors();
    &reading_lastnames();
    &reading_lastname_errors();
    my $enc=&analyze_encoding($analyze_encoding,$analyze_encoding);
    if ($show_special_char_lines==1){
        my $count=0;
	foreach my $line (@special_char_lines){
            my $conv = Text::Iconv->new($enc,"utf8");
            my $line_utf8 = $conv->convert($line);
            if ($non_umlaut==1){
                # äöüÄÖÜß works because its unicode
                if ($line_utf8=~/[^äöüÄÖÜßa-zA-Z0-9\-\.;_\/\s]/) { 
                    $count++;
                    print "$count)  $line_utf8\n";
                }
            } else {
                    $count++;
                    print "$count)  $line_utf8\n";
            }
        }
    }
    &print_analyzed_encoding($analyze_encoding);
    my $result="$analyze_encoding is $enc encoded";
    &result_sophomorix_add_summary({
                         NAME=>"ANALYZE-ENCODING", 
                         RESULT=>$result, 
                         FORMAT_TYPE => 0,
                         FILE => $analyze_encoding,
                         ENCODING => $enc,
                         sophomorix_result=>\%sophomorix_result,
			       });
    &log_script_end(\@arguments,\%sophomorix_result,\%sophomorix_config,$json);
}



################################################################################
# Start
################################################################################
# cleaning up last check
system("mkdir -p $sophomorix_config{'INI'}{'PATHS'}{'LOG'}");
&print_title("Cleaning up last check");
system("rm -f $DevelConf::path_conf_tmp/*.csv*");
system("rm -f $sophomorix_config{'INI'}{'PATHS'}{'CHECK_RESULT'}/sophomorix.*");
system("rm -f $sophomorix_config{'INI'}{'PATHS'}{'REPORT_OFFICE'}/report.office.*");

# create result files
my $add_file=$sophomorix_config{'INI'}{'PATHS'}{'CHECK_RESULT'}."/sophomorix.add";
open (ADD, ">$add_file");
my $update_file=$sophomorix_config{'INI'}{'PATHS'}{'CHECK_RESULT'}."/sophomorix.update";
open (UPDATE, ">$update_file");
my $kill_file=$sophomorix_config{'INI'}{'PATHS'}{'CHECK_RESULT'}."/sophomorix.kill";
open (KILL, ">$kill_file");
my $nochange_file=$sophomorix_config{'INI'}{'PATHS'}{'CHECK_RESULT'}."/sophomorix.nochange";
open (NOCHANGE, ">$nochange_file");
my $error_file=$sophomorix_config{'INI'}{'PATHS'}{'CHECK_RESULT'}."/sophomorix.error";
open (ERRORFILE, ">$error_file");

# ============================================================
# analyzing encoding of all filtered user files in tmp
# ============================================================
&reading_firstnames();
&reading_firstname_errors();
&reading_lastnames();
&reading_lastname_errors();
foreach my  $user_file (@filelist){
    &analyze_encoding($user_file,$user_file);
}



# ============================================================
# reading and checking all filtered user files
# ============================================================
system("mkdir -p $DevelConf::path_conf_tmp");

&print_title("Analyzing user files ...");
foreach my $user_file (@filelist){
    my $count=0; # reset line counter
    my $filename = basename($user_file);
    # fetching some config data
    $school=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'};

    my $enc_used=&get_encoding($filename);
    open(USERS,"$user_file") || 
         die "ERROR: $user_file not found!";  
    open(USERSUTF8,">$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_UTF8'}") || 
         die "ERROR: $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_UTF8'} not found!";  
    open(REPORT,">$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_REPORT_OFFICE'}") || 
         die "ERROR: $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_REPORT_OFFICE'} not found!"; 
    print REPORT "Office Report for: $user_file\n"; 
    print REPORT "Date_Time:         $time_stamp_file\n";
 
    while(<USERS>){
        $count++;
        my $line=$_;
        &analyze_user_line($line,$user_file,$filename,$school,$count,$enc_used,"no","USER_FILE");
    }

    close(USERS);
    close(USERSUTF8);
    close(REPORT);
}



# ============================================================
# injecing lines given by option
# ============================================================
&print_title("Reading injected lines ...");
my $count=0;
foreach my $inject (@injectlines){
    print "    * $inject\n";
    my ($filename,$line)=split(/:/,$inject,2); # split in 2 parts
    if (exists $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'}){
        $school=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'};
        print "        file:   $filename\n";
        print "        school: $school\n";
        print "        line:   $line\n";
        $count++;
        my $file_abs=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS'};
        # opening the output file to APPEND entries
        open(USERSUTF8,">>$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_UTF8'}") || 
             die "ERROR: $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_UTF8'} not found!";  
        open(REPORT,">>$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_REPORT_OFFICE'}") || 
         die "ERROR: $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS_REPORT_OFFICE'} not found!";  
        &analyze_user_line($line,$file_abs,$filename,$school,$count,"utf8","yes","USER_FILE");
        close(USERSUTF8);
        close(REPORT);
    } else {
        print "        WARNING: $filename is not valid on this ",
              "server (skipping this line)\n";
    }
}

# ============================================================
# reading extraclasses.csv
# ============================================================
&print_title("Reading class files ...");
foreach my $class_file (@class_filelist){
    my $count=0; # reset line counter
    my $filename = basename($class_file);
    # fetching some config data
    $school=$sophomorix_config{'FILES'}{'CLASS_FILE'}{$filename}{'SCHOOL'};

    #my $enc_used=&get_encoding($filename);
    open(CLASSES,"$class_file") || 
         die "ERROR: $class_file not found!";  
    open(USERSUTF8,">>$sophomorix_config{'FILES'}{'CLASS_FILE'}{$filename}{'PATH_ABS_UTF8'}") || 
         die "ERROR: $sophomorix_config{'FILES'}{'CLASS_FILE'}{$filename}{'PATH_ABS_UTF8'} not found!";  
    open(REPORT,">$sophomorix_config{'FILES'}{'CLASS_FILE'}{$filename}{'PATH_ABS_REPORT_OFFICE'}") || 
         die "ERROR: $sophomorix_config{'FILES'}{'CLASS_FILE'}{$filename}{'PATH_ABS_REPORT_OFFICE'} not found!"; 
    print REPORT "Office Report for: $class_file\n"; 
    print REPORT "Date_Time:         $time_stamp_file\n";
 
    while(<CLASSES>){
        $count++;
        chomp();
        s/^ //g; # remove spaces oat beginning of line
        if(/^\#/){ # ignore commented lines
            next;
	}
        if($_ eq ""){
            next;
        }
        print "HERE: $_\n";
  
        my ($course,
            $course_basename,
            $course_count,
            $course_date,
            $course_comment,
            $course_password,
            $course_enddate)=split(/;/);
        my ($end_day, $end_month, $end_year)=split(/\./, $course_enddate);

        # exit member number is not a number 
        if ($course_count=~/[^0-9]/){
            print "\nERROR: Number of users $course_count contains non numbers\n";
            print "   LINE: $_\n";
            print "   FILE: $class_file\n";
            exit;
        }
        # exit if course is double ???
        # what about password ??? 

        # check if end date is reached
        my $course_enddate_epoch=timelocal(0, 0, 0, $end_day, $end_month-1, $end_year);
        print "EPOCH now:        $sophomorix_config{'UNIX'}{'EPOCH'}\n";
        print "EPOCH course end: $course_enddate_epoch\n";
        if ($course_enddate_epoch>=$sophomorix_config{'UNIX'}{'EPOCH'}){
            # create lines
            for( my $index = 1 ; $index<=$course_count  ; $index++) {
                # create num string
                my $num_string;
                if (exists $convert_day{$index}){
                    $num_string=$convert_day{$index};
                } else {
                    $num_string=$index;
                }
                my $line=$course.";".$num_string.";".$course_comment.";".$course_date.";".$course_basename.$num_string;
                print "    user $num_string/$course_count: $line\n";
                my $enc_used="UTF8";
                &analyze_user_line($line,$class_file,$filename,$school,$count,$enc_used,"no","CLASS_FILE");
            }
        }
    }

    close(CLASSES);
    close(USERSUTF8);
    close(REPORT);
}



# --dump-files
if ($dump_files==1){
    &json_dump({json => $json,
                jsoninfo => "USERS",
                jsoncomment => "All users read from all user files",
                log_level => $Conf::log_level,
                hash_ref=>\%users_file,
                sophomorix_config=>\%sophomorix_config,
               });
}



# --follow
# show the line
if ($follow ne ""){
    my $identifier=$users_file{'file'}{$follow_file}{$follow_line}{'identifier_ascii'};
    if (not defined $identifier){
        print "   * Line $follow_line in file $follow_file contains no usable data\n";
    } else {
        print "   * LINE ORIG: $users_file{'identifier_ascii'}{$identifier}{LINE_OLD}\n";
        print "   * LINE UTF8: $users_file{'identifier_ascii'}{$identifier}{LINE_NEW}\n";
    }
}



# ============================================================
# asking AD for users
# ============================================================
&print_title("Searching AD for users ...");
# fetch system data
# my ($ref_AD) = &AD_get_AD({ldap=>$ldap,
#                            root_dse=>$root_dse,
#                            root_dns=>$root_dns,
#                            computers=>"FALSE",
#                            rooms=>"FALSE",
#                            administratorclasses=>"TRUE",
#                            users=>"TRUE",
#                            dnszones=>"FALSE",
#                            dnsnodes=>"FALSE",
#                            sophomorix_config=>\%sophomorix_config,
#              });


my ($ref_AD_check) = &AD_get_AD_for_check({ldap=>$ldap,
                                     root_dse=>$root_dse,
                                     root_dns=>$root_dns,
                                     sophomorix_config=>\%sophomorix_config,
                                   });


# --dump-AD
if ($dump_AD==1){
    &json_dump({json => $json,
                jsoninfo => "SEARCH",
                jsoncomment => "AD Content",
                log_level => $Conf::log_level,
                hash_ref=>$ref_AD_check,
                sophomorix_config=>\%sophomorix_config,
              });
}



my ($ref_login_avoid) = &get_login_avoid(\%sophomorix_config);
# --dump-login-avoid
if ($dump_login_avoid==1){
    &json_dump({json => $json,
                jsoninfo => "LOGIN_AVOID",
                jsoncomment => "Logins to avoid from log files",
                log_level => $Conf::log_level,
                hash_ref=>$ref_login_avoid,
                sophomorix_config=>\%sophomorix_config,
              });
}


# ============================================================
# Find Matches: Walk thhrough all files and identifiers in %users_file
# ============================================================

# dynamic matching data ist contained in %Match
# reading user files populate these subhashes (file identifiers):
# $Match{'file_dynamic_identifiers_ascii'} or $users_file{'file_dynamic_identifiers_utf8'}
# and populated from AD by subs (AD identifiers): 
# $Match{'ad_dynamic_identifiers_ascii'} $Match{'ad_dynamic_identifiers_utf8'}

# no migration
#&populate_ad_dynamic_identifiers_utf8();

# migration
&populate_ad_dynamic_identifiers_ascii();

# find exact matches
&print_title("Finding exact user matches ...");
&find_migration_unid_matches();
&find_migration_ascii_matches();

# find approx matches
# create loop that stopps itself???
&find_migration_ascii_approx_matches(1);
&find_migration_ascii_approx_matches(2);
&find_migration_ascii_approx_matches(3);
&find_migration_ascii_approx_matches(4);

# marriage, birthdate, ... and such matches ???

# check if this is so:
# track approx number with matches 



# --dump-matches
if ($dump_matches==1){
    &json_dump({json => $json,
                jsoninfo => "MATCH",
                jsoncomment => "File user -> AD matches",
                log_level => $Conf::log_level,
                hash_ref=>\%Match,
                sophomorix_config=>\%sophomorix_config,
              });
}



###########################################################################
# Begin writing into result files
###########################################################################
&print_title("Writing the result files:");


# ADD users that could not be matched to AD users
############################################################
foreach my $line_new ( @{ $Match{'lines'} } ){
    if (not defined $Match{'ACTION'}{$line_new}{'sAMAccountName'}){
        &write_add_file($line_new);
    }
}

# Users in AD:
# UPDATE or KILL or NOCHANGE
############################################################
foreach my $sam ( keys %{$ref_AD_check->{'sAMAccountName'}} ) { 
    # test all users in AD
    my $update=0; # if > 0 write to sophomorix.update
    my $kill=0; # if > 0 write to sophomorix.kill
    my $old_unid=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixUnid'};
    my $new_unid="---";
    my $old_surname_ascii=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixSurnameASCII'};
    my $new_surname_ascii="---";
    my $old_firstname_ascii=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixFirstnameASCII'};
    my $new_firstname_ascii="---";
    my $old_birthdate=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixBirthdate'};
    my $new_birthdate="---";
    my $old_surname_utf8=$ref_AD_check->{'sAMAccountName'}{$sam}{'sn'};
    my $new_surname_utf8="---";
    my $old_firstname_utf8=$ref_AD_check->{'sAMAccountName'}{$sam}{'givenName'};
    my $new_firstname_utf8="---";
    my $old_filename=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminFile'};
    my $new_filename="---";
    my $old_status=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'};
    my $new_status="---";
    my $old_role=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixRole'};
    my $new_role="---";

    my $new_class="---";
    my $old_school=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixSchoolname'};
    my $new_school="---";

    # dirty fix to have class without
    my $old_class=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminClass'};
    $old_class=~s/^$old_school-//;
    
    ##################################################
    # check status update for users in AD
    &test_UEAS_T_update($sam,\$update,\$new_status);
    &test_T_DA_update($sam,\$update,\$new_status);
    &test_DL_RA_update($sam,\$update,\$new_status);
    &test_R_A_update($sam,\$update,\$new_status);
    ##################################################
    if (exists $Match{'action_BY_sAMAccountName'}{$sam}){
        # check identifier update for matched users in AD
        &test_user_update($sam,
                          \$update,
                          \$new_unid,
                          \$new_surname_ascii,
                          \$new_firstname_ascii,
                          \$new_birthdate,
                          \$new_surname_utf8,
                          \$new_firstname_utf8,
                          \$new_filename,
                          \$new_role,
                          \$new_class,
	                  \$new_school,
                         );
    }

    if ($update>0){
        # write to sophomorix.update
        my $update_line=$sam."::".
                        $old_unid."::".
                        $new_unid."::".
                        $old_surname_ascii."::".
                        $new_surname_ascii."::".
                        $old_firstname_ascii."::".
                        $new_firstname_ascii."::".
                        $old_birthdate."::".
                        $new_birthdate."::".
                        $old_surname_utf8."::".
                        $new_surname_utf8."::".
                        $old_firstname_utf8."::".
                        $new_firstname_utf8."::".
                        $old_filename."::".
                        $new_filename."::".
                        $old_status."::".
                        $new_status."::".
                        $old_role."::".
                        $new_role."::".
                        $old_class."::".
                        $new_class."::".
                        $old_school."::".
                        $new_school."::".
                        "\n";
        print UPDATE $update_line;
    } else {
        # nothing to update 
        # write to sophomorix.kill or sophomorix.nochange
        &test_RK_kill($sam,\$kill);
        if ($kill>0){
            # write to sophomorix.kill
            my $kill_line=$ref_AD_check->{'sAMAccountName'}{$sam}{'IDENTIFIER_ASCII'}."::".
                          $sam."::".
                          $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminClass'}."::".
                          $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixSchoolname'}."::\n";               
            print KILL $kill_line;
        } else {
            # write to sophomorix.nochange
            my $nochange_line=$sam."::".
                              $ref_AD_check->{'sAMAccountName'}{$sam}{'sn'}."::".
                              $ref_AD_check->{'sAMAccountName'}{$sam}{'givenName'}."::".
                              $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixBirthdate'}."::".
                              $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'}."::".
                              $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminClass'}."::".
                              $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminFile'}."::".
                              "\n";
            print NOCHANGE $nochange_line;
        }
    }
}

close(ADD);
close(UPDATE);
close(KILL);
close(NOCHANGE);
#close(ERRORFILE);


############################################################
# create overview in %sophomorix_result
############################################################
&result_sophomorix_add_summary({
                     NAME=>"HEADER", 
                     TITLE=>"Overview of what can be done:", 
                     sophomorix_result=>\%sophomorix_result,
			       });

my $linecount_add=`wc -l $add_file`;
chomp($linecount_add);
my ($lc_add,$tmp_add)=split(/\s/,$linecount_add);
&result_sophomorix_add_summary({
                     NAME=>"ADD", 
                     RESULT=>$lc_add, 
                     RESULT_TYPE => "integer",
                     DESCRIPTION_POST => "users can be added in ".basename($add_file), 
                     DESCRIPTION_PRE => "users in ".basename($add_file), 
                     FORMAT_TYPE => 1,
                     sophomorix_result=>\%sophomorix_result,
			       });

my $linecount_update=`wc -l $update_file`;
chomp($linecount_update);
my ($lc_update,$tmp_update)=split(/\s/,$linecount_update);
&result_sophomorix_add_summary({
                     NAME=>"UPDATE", 
                     RESULT=>$lc_update, 
                     RESULT_TYPE => "integer",
                     DESCRIPTION_POST => "users can be updated in ".basename($update_file), 
                     DESCRIPTION_PRE => "users in ".basename($update_file), 
                     FORMAT_TYPE => 1,
                     sophomorix_result=>\%sophomorix_result,
			       });

my $linecount_kill=`wc -l $kill_file`;
chomp($linecount_kill);
my ($lc_kill,$tmp_kill)=split(/\s/,$linecount_kill);
&result_sophomorix_add_summary({
                     NAME=>"KILL", 
                     RESULT=>$lc_kill, 
                     RESULT_TYPE => "integer",
                     DESCRIPTION_POST => "users can be killed in ".basename($kill_file), 
                     DESCRIPTION_PRE => "users in ".basename($kill_file), 
                     FORMAT_TYPE => 1,
                     sophomorix_result=>\%sophomorix_result,
			       });

my $linecount_nochange=`wc -l $nochange_file`;
chomp($linecount_nochange);
my ($lc_nochange,$tmp_nochange)=split(/\s/,$linecount_nochange);
&result_sophomorix_add_summary({
                     NAME=>"NOCHANGE", 
                     RESULT=>$lc_nochange, 
                     RESULT_TYPE => "integer",
                     DESCRIPTION_POST => "users are not to be changed in ".basename($nochange_file), 
                     DESCRIPTION_PRE => "users in ".basename($nochange_file), 
                     FORMAT_TYPE => 1,
                     sophomorix_result=>\%sophomorix_result,
			       });

my $linecount_error=`wc -l $error_file`;
chomp($linecount_error);
my ($lc_error,$tmp_error)=split(/\s/,$linecount_error);
&result_sophomorix_add_summary({
                     NAME=>"ERRORFILE", 
                     RESULT=>$lc_error, 
                     RESULT_TYPE => "integer",
                     DESCRIPTION_POST => "users with errors in ".basename($error_file), 
                     DESCRIPTION_PRE => "users in ".basename($error_file), 
                     FORMAT_TYPE => 1,
                     sophomorix_result=>\%sophomorix_result,
			       });




&AD_unbind_admin($ldap);
&log_script_end(\@arguments,\%sophomorix_result,\%sophomorix_config,$json);


################################################################################
# Sub
################################################################################

# test status updates
################################################################################
sub test_UEAS_T_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "U" or
             $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "E" or
             $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "A" or
             $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "S"
           ){
            # update to T if not matched to a user in files
            if (not exists $Match{'action_BY_sAMAccountName'}{$sam}){
                if($Conf::log_level>=2){
                    print "   * $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} -> T\n";
	        }
                ${$new_status_ref}="T";
                ${$update_ref}++;
            }
    }
}


sub test_T_DA_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "T"){
        if($Conf::log_level>=2){
            print "* Testing $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'},",
                  " TolerationDate: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixTolerationDate'}\n";
        }
        my $file=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminFile'};
        my $toleration_date_epoch=&ymdhms_to_epoch($ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixTolerationDate'});
        my $toleration_time_days;
        if (defined $sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'TOLERATION_TIME'} ){
            $toleration_time_days=$sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'TOLERATION_TIME'};
        } else {
            # for migration, high enough to be sure it is not updated
            $toleration_time_days=1000;
        }
        my $toleration_end_epoch=$toleration_date_epoch+86400*$toleration_time_days;
        if($Conf::log_level>=2){
            print "    Toleration end: $toleration_end_epoch ($ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixTolerationDate'}",
                  " +  $toleration_time_days days)\n";
            print "    Today:          $time_stamp_epoch\n";
        }
        if (not exists $Match{'action_BY_sAMAccountName'}{$sam} and 
            $time_stamp_epoch > $toleration_end_epoch){
            # update to D if 
            #     - not matched to a user in files
            #     - and toleration time expired
            if($Conf::log_level>=2){
                print "    ----> $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} -> D\n";
            }
            ${$new_status_ref}="D";
            ${$update_ref}++;
	} elsif (exists $Match{'action_BY_sAMAccountName'}{$sam}){
            # update to A if 
            #     - matched to a user in files
            if($Conf::log_level>=2){
                print "    ----> $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} -> A\n";
            }
            ${$new_status_ref}="A";
            ${$update_ref}++;
	} else {
            # do nothing
            if($Conf::log_level>=2){
                print "    ----> Toleration end not reached\n";
            }
        }
    }
}



sub test_DL_RA_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "D" or
        $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "L"
       ){
        if($Conf::log_level>=2){
            print "* Testing $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'},",
                  " DeactivationDate: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixDeactivationDate'}\n";
        }
        my $file=$ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminFile'};
        my $deactivation_date_epoch=&ymdhms_to_epoch($ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixDeactivationDate'});
        my $deactivation_time_days;
        if (defined $sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'DEACTIVATION_TIME'} ){
            $deactivation_time_days=$sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'DEACTIVATION_TIME'};
        } else {
            # for migration, high enough to be sure it is not updated
            $deactivation_time_days=1000;
        }
        my $deactivation_end_epoch=$deactivation_date_epoch+86400*$deactivation_time_days;
        if($Conf::log_level>=2){
            print "    Deactivation end: $deactivation_end_epoch ($ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixDeactivationDate'}",
                  " + $deactivation_time_days days)\n";
            print "    Today:            $time_stamp_epoch\n";
        }
        ########################################
        if (not exists $Match{'action_BY_sAMAccountName'}{$sam} and 
            $time_stamp_epoch > $deactivation_end_epoch){
            # update to R/put in kill-file  if 
            #     - not matched to a user in files
            #     - and deactivation time expired
            # 1) update status to R
            if($Conf::log_level>=2){
                print "    ----> $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} -> R\n";
	    }
            ${$new_status_ref}="R";
            ${$update_ref}++;
            # 2) put user in kill file
            if($Conf::log_level>=2){
                print "    ----> $sam is put into kill file\n";
	    }
            # creating the line
            my $kill_line=
                $ref_AD_check->{'sAMAccountName'}{$sam}{'IDENTIFIER_ASCII'}."::".
                $sam."::".
                $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminClass'}."::".
                $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixSchoolname'}."::\n";               
            print KILL $kill_line;
        } elsif (exists $Match{'action_BY_sAMAccountName'}{$sam} and 
            $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "D"){
            # update to A if 
            #     - matched to a user in files
            #     - old status is D (not for status L)
            if($Conf::log_level>=2){
                print "    ----> $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} -> A\n";
	    }
            ${$new_status_ref}="A";
            ${$update_ref}++;
        ########################################
	} else {
            if($Conf::log_level>=2){
                print "    ----> Deactivation end not reached\n";
  	    }
        }
     }
}



sub test_R_A_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "R" and 
        exists $Match{'action_BY_sAMAccountName'}{$sam} 
       ){
        # update R to A if 
        #     - matched to a user in files
        if($Conf::log_level>=2){
            print "    ----> $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} -> A\n";
	}
        ${$new_status_ref}="A";
        ${$update_ref}++;
    }
}



sub test_RK_kill{
    my ($sam,$kill_ref)=@_;
    if ( $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "K" or
         ($ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} eq "R" and not exists $Match{'action_BY_sAMAccountName'}{$sam})
       ){
        # kill if status is  R or K
        if($Conf::log_level>=2){
            print "    ----> $sam: $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixStatus'} -> sophomorix.kill\n";
        }
        ${$kill_ref}++;
    }
}



# test user update
################################################################################
sub test_user_update {
    my ($sam,
        $update_ref,
        $new_unid_ref,
        $new_surname_ascii_ref,
        $new_firstname_ascii_ref,
        $new_birthdate_ref,
        $new_surname_utf8_ref,
        $new_firstname_utf8_ref,
        $new_filename_ref,
        $new_role_ref,
        $new_class_ref,
        $new_school_ref,
       )=@_;
    my $line_new=$Match{'action_BY_sAMAccountName'}{$sam};
   
    # count changes to attributes, 
    # update unid only when ALL other values are the same
    my $identifier_class_changes=0;

    # new_surname_ascii
    if ( ($Match{'ACTION'}{$line_new}{'surname_ascii'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixSurnameASCII'})){
        # no update
        ${$new_surname_ascii_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_surname_ascii_ref}=$Match{'ACTION'}{$line_new}{'surname_ascii'};
        $identifier_class_changes++;
    }

    # new_firstname_ascii
    if ( ($Match{'ACTION'}{$line_new}{'firstname_ascii'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixFirstnameASCII'} )){
        # no update
        ${$new_firstname_ascii_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_firstname_ascii_ref}=$Match{'ACTION'}{$line_new}{'firstname_ascii'};
        $identifier_class_changes++;
    }


    # new_surname_utf8
    if ( ($Match{'ACTION'}{$line_new}{'surname_utf8'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sn'})){
        # no update
        ${$new_surname_utf8_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_surname_utf8_ref}=$Match{'ACTION'}{$line_new}{'surname_utf8'};
        $identifier_class_changes++;
    }

    # new_firstname_utf8
    if ( ($Match{'ACTION'}{$line_new}{'firstname_utf8'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'givenName'} )){
        # no update
        ${$new_firstname_utf8_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_firstname_utf8_ref}=$Match{'ACTION'}{$line_new}{'firstname_utf8'};
        $identifier_class_changes++;
    }

    # birthdate
    if ( ($Match{'ACTION'}{$line_new}{'birthdate'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixBirthdate'} )){
        # no update
        ${$new_birthdate_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_birthdate_ref}=$Match{'ACTION'}{$line_new}{'birthdate'};
        $identifier_class_changes++;
    }

    # filename
    if ( ($Match{'ACTION'}{$line_new}{'filename'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminFile'} )){
        # no update
        ${$new_filename_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_filename_ref}=$Match{'ACTION'}{$line_new}{'filename'};
        $identifier_class_changes++;
    }

    # role
    if ( ($Match{'ACTION'}{$line_new}{'role'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixRole'} )){
        # no update
        ${$new_role_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_role_ref}=$Match{'ACTION'}{$line_new}{'role'};
        $identifier_class_changes++;
    }

    # adminclass(with prefix) must be created from school and class
    my $adminclass;
    if ($adminclass=$Match{'ACTION'}{$line_new}{'school'} eq $DevelConf::name_default_school){
        # default-school
        $adminclass=$Match{'ACTION'}{$line_new}{'class'};
    } else {
        $adminclass=$Match{'ACTION'}{$line_new}{'school'}."-".$Match{'ACTION'}{$line_new}{'class'};
    }

    if ( ($adminclass eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminClass'} )){
        # no update
        ${$new_class_ref}="---";
    } else {
        # update
        # exit if new group is a user
        if (exists $ref_AD_check->{'sAMAccountName'}{$adminclass}){
            print "\n";
  	    print "ERROR: User \"$sam\" is configured be moved from class \"".
                  $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixAdminClass'}.
                  "\" to \"".
                  $adminclass.
                  "\"\n";
            print "  BUT: The target class \"$adminclass\" is a user (not a group)\n";
            print "  You must:\n";
            print "     A) map the groupname \"$adminclass\" to another name\n";
            print "     B) Edit the groupname of \"$sam\" in the file ${$new_filename_ref}\n";
            exit;
        }
        ${$update_ref}++;
        # ${$new_class_ref}=$adminclass; # with prefix
        ${$new_class_ref}=$Match{'ACTION'}{$line_new}{'class'}; # without prefix
        $identifier_class_changes++;
    }

    # school
    if ( ($Match{'ACTION'}{$line_new}{'school'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixSchoolname'} )){
        # no update
        ${$new_school_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$new_school_ref}=$Match{'ACTION'}{$line_new}{'school'};
        $identifier_class_changes++;
    }

    # unid
    if ( ($Match{'ACTION'}{$line_new}{'unid'} eq $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixUnid'}) or
         ($Match{'ACTION'}{$line_new}{'unid'} eq "" and $ref_AD_check->{'sAMAccountName'}{$sam}{'sophomorixUnid'} eq "---") ){
        # no update
        ${$new_unid_ref}="---";
    } else {
        # update only if user is identically matched
        if ($identifier_class_changes==0){
            if ($Match{'ACTION'}{$line_new}{'unid'} eq "---"){
                # write empty value to sophomorix.update, so sophomorix-update 
                # will not skip it ("---" would mean skip it)
                ${$new_unid_ref}="";
                ${$update_ref}++;
            } else {
                ${$new_unid_ref}=$Match{'ACTION'}{$line_new}{'unid'};
                ${$update_ref}++;
            }
        } else {
            print "$sam not uploading new unid: identifier or class changed\n";
        }
    }
}



# writing lines into files
################################################################################
sub write_add_file {
    my ($line_new)=@_;
    if($Conf::log_level>=2){
        print "$line_new\n";
        print "   * not matched to any sAMAccountName\n";
    }
    my $status;
    if ($Match{'ACTION'}{$line_new}{'inject'} eq "yes"){
        $status="S"; # injected users have status S=selfactivated
    } else {
        $status="U";
    }
    my $login=&create_test_login($Match{'ACTION'}{$line_new}{'identifier_ascii'}, # user data
                                 $Match{'ACTION'}{$line_new}{'filename'}, # filename for password length
                                 $Match{'ACTION'}{$line_new}{'login'}, # proposed login (will be tested)
                                 $ref_AD_check, # forbidden logins
                                 $ref_login_avoid, # logins to avoid
                                 $Match{'ACTION'}{$line_new}{'line_count'},
                                 \%users_file,
                                 \%sophomorix_config);
    my $add_line=$Match{'ACTION'}{$line_new}{'filename'}."::".
                 $Match{'ACTION'}{$line_new}{'class'}."::".
                 $Match{'ACTION'}{$line_new}{'identifier_ascii'}."::".
                 $login."::".
                 "---::". # firstpassword
                 "---::". # uid
                 "---::". # gid
                 $Match{'ACTION'}{$line_new}{'unid'}."::".
                 $Match{'ACTION'}{$line_new}{'school'}."::".
                 $Match{'ACTION'}{$line_new}{'role'}."::".
                 $Match{'ACTION'}{$line_new}{'surname_utf8'}."::".
                 $Match{'ACTION'}{$line_new}{'firstname_utf8'}."::".
                 $status."::".   # status
                 "---::". # creationdate
                 "---::". # tolerationdate
                 "---::". # deactivationdate
                 "---::". # sambantpassword
                 "---::". # userpassword
                 "\n";
    if ($login ne "---"){
        print ADD $add_line;
    } else {
        print "\n   ERROR: Login for $line_new could no be created\n\n";
        exit;
    }
}



# UTF8 match
################################################################################
sub populate_ad_dynamic_identifiers_utf8 {
    foreach my $identifier_utf8 (keys %{$ref_AD_check->{'LOOKUP'}{'user_BY_identifier_utf8'}} ) { 
        $Match{'ad_dynamic_identifiers_utf8'}{$identifier_utf8}="ad, not matched";
    } 
}



# Migration match
################################################################################
# call this in the end of all matches ??????????????????????ßßß
sub show_dynamic_identifiers_ascii {
    my $file_count=0;
    my $ad_count=0;
    my @file_ids=();
    my @ad_ids=();
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        push @file_ids, $identifier_ascii;
        $file_count++;
    } 
    foreach my $identifier_ascii (keys %{$Match{'ad_dynamic_identifiers_ascii'}} ) {
        push @ad_ids, $identifier_ascii;
        $ad_count++;
    }
    my $diff=$ad_count-$file_count;
    &print_title("$file_count users in files to be matched with $ad_count in AD (Diff: $diff)");
    if ($file_count==0 or $ad_count==0){
	return 0;
    } else {
        if($Conf::log_level>=2){
	    @file_ids= sort @file_ids;
            print "file_dynamic_identifiers_ascii:\n";
            foreach my $id (@file_ids){
                print "   * $id (in files)\n";
            }   
	    @ad_ids = sort @ad_ids;
            print "ad_dynamic_identifiers_ascii:\n";
            foreach my $id (@ad_ids){
                my $status=
                print "   * $id ($ref_AD_check->{'LOOKUP'}{'user_BY_identifier_ascii'}{$id} in AD,",
                      " status $ref_AD_check->{'LOOKUP'}{'sophomorixStatus_BY_identifier_ascii'}{$id})\n";
            }    
        }
        return 1;
    }
}



sub populate_ad_dynamic_identifiers_ascii {
    foreach my $identifier_ascii (keys %{$ref_AD_check->{'LOOKUP'}{'user_BY_identifier_ascii'}} ) { 
        $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii}="ad, not matched";
    } 
}



sub find_migration_ascii_approx_matches {
    my ($max_edit_distance) = @_;
    my $run="approx_".$max_edit_distance."_run";
    print "\n";
    &print_title("Migration approx matching (max. edit distance $max_edit_distance)");
    my $ret=&show_dynamic_identifiers_ascii();
    if ($ret==0){
        print "---> Nothing to do anymore\n";
	    return 0;
    }
    my $line_count=0;
    my $matched_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        $line_count++;
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        print " $filename:",
              "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
              "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
              "$identifier_ascii\n";
        my $count=0;
        foreach my $identifier_ascii_ad ( keys %{ $Match{'ad_dynamic_identifiers_ascii'} } ){
            $count++;
            my $edit_distance=&edit_distance($identifier_ascii,$identifier_ascii_ad);
            if($Conf::log_level>=3){
                print "   * $identifier_ascii <---> $identifier_ascii_ad ($count)\n";
                print "      * $edit_distance (Edit distance)\n";
            }
            if ($edit_distance <= $max_edit_distance){
                # APPROX MATCH
                my $sam=$ref_AD_check->{'LOOKUP'}{'user_BY_identifier_ascii'}{$identifier_ascii_ad};
                print "   * APPROXMATCH($edit_distance): $identifier_ascii_ad\n";
                delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii_ad};
                # save match to delete this match from list
                $Match{'file_approx_match'}{$run}{$identifier_ascii}=$edit_distance;
                # remove the approx matches from the list
                delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};

                # save to write later
                my $sub=(caller(0))[3];
                my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
                $Match{'ACTION'}{$line_new}{'sAMAccountName'}=$sam;
                $Match{'ACTION'}{$line_new}{'MATCH_SUB'}="$sub $max_edit_distance";
                $Match{'ACTION'}{$line_new}{'status'}=
                    $ref_AD_check->{'LOOKUP'}{'sophomorixStatus_BY_identifier_ascii'}{$identifier_ascii};
                # reverse action_BY_sAMAccountName
                $Match{'action_BY_sAMAccountName'}{$sam}=$line_new;
            }
        }
    }
    &print_title("Migration approx matching ($line_count tested)");
}



sub find_migration_ascii_matches {
    print "\n";
    &print_title("Migration matching ascii-to-utf8");
    &show_dynamic_identifiers_ascii();
    my $line_count=0;
    my $matched_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        $line_count++;
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        if ( exists $ref_AD_check->{'LOOKUP'}{'user_BY_identifier_ascii'}{$identifier_ascii} ){
            # MATCH
            my $sam=$ref_AD_check->{'LOOKUP'}{'user_BY_identifier_ascii'}{$identifier_ascii};
            if($Conf::log_level>=2){
                print "    MATCH: $identifier_ascii to $sam\n";
            }

            # save to write later
            my $sub=(caller(0))[3];
            $Match{'file'}{$filename}{$identifier_ascii}=$sam;
            my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
            $Match{'ACTION'}{$line_new}{'sAMAccountName'}=$sam;
            $Match{'ACTION'}{$line_new}{'MATCH_SUB'}="$sub";
            $Match{'ACTION'}{$line_new}{'status'}=
                $ref_AD_check->{'LOOKUP'}{'sophomorixStatus_BY_identifier_ascii'}{$identifier_ascii};
            # reverse action_BY_sAMAccountName
            $Match{'action_BY_sAMAccountName'}{$sam}=$line_new;

            # remove from ad_to_be_matched
            delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii};
            delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};
            $matched_count++;
        } else {
            # NO MATCH
            print " $filename:",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                  "$identifier_ascii\n";
            print "   --> No exact match for $identifier_ascii\n";
            $Match{'find_migration_ascii_matches'}{$identifier_ascii}="no exact identifier match possible";
            $not_matched_count++;
        }
    }
    &print_title("ascii--to-utf8-Matching $line_count lines: $matched_count matched, $not_matched_count unmatched");
}



sub find_migration_unid_matches {
    print "\n";
    &print_title("unidMatching lines to accounts:");
    &show_dynamic_identifiers_ascii();
    my $line_count=0;
    my $matched_count=0;
    my $no_unid_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        $line_count++;
        if ($users_file{'identifier_ascii'}{$identifier_ascii}{UNID} ne ""){
            # finding a unid match 
            if ( exists $ref_AD_check->{'LOOKUP'}{'user_BY_sophomorixUnid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}} and
                 $ref_AD_check->{'LOOKUP'}{'user_BY_sophomorixUnid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}} ne "---"
               ){
                # MATCH
                my $sam=$ref_AD_check->{'LOOKUP'}{'user_BY_sophomorixUnid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}};
                my $role=$ref_AD_check->{'LOOKUP'}{'sophomorixRole_BY_sAMAccountName'}{$sam};
                # fetch the identifier from AD with same unid
                my $identifier_ascii_from_AD=
		    $ref_AD_check->{'LOOKUP'}{'identifier_ascii_BY_sophomorixUnid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}};
                if($Conf::log_level>=2){
                    print " $filename:",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                          "$identifier_ascii\n";
	            print "  --> unidMATCH: $sam --> ",
                          "$identifier_ascii_from_AD\n";
                }
                $matched_count++;
                # remove from dynamic hashes
                delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii_from_AD};
                delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};

                # save to write later
                my $sub=(caller(0))[3];
                $Match{'file'}{$filename}{$identifier_ascii}=$sam;
                my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
                $Match{'ACTION'}{$line_new}{'sAMAccountName'}=$sam;
                $Match{'ACTION'}{$line_new}{'MATCH_SUB'}="$sub";
                $Match{'ACTION'}{$line_new}{'status'}=
                    $ref_AD_check->{'LOOKUP'}{'sophomorixStatus_BY_identifier_ascii'}{$identifier_ascii};
                # reverse action_BY_sAMAccountName
                $Match{'action_BY_sAMAccountName'}{$sam}=$line_new;

            } else {
                # NO MATCH
                $Match{'find_migration_unid_matches'}{$identifier_ascii}="no unid match";
                $not_matched_count++;
                if($Conf::log_level>=2){
                    print " $filename:",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                          "$identifier_ascii\n";
                    print "   --> Unid $users_file{'identifier_ascii'}{$identifier_ascii}{UNID}",
                          " not found in AD\n";
                }
            }
        } else {
            $no_unid_count++;
            $Match{'find_migration_unid_matches'}{$identifier_ascii}="no unid, no match possible";
        }
    }
    &print_title("unidMatching $line_count lines: $matched_count matched, $not_matched_count unmatched, $no_unid_count without unid");
}



# APPROX stuff
################################################################################
sub edit_distance {
    my ($string1,$string2)=@_;
    my $string;
    my $pattern;
    # the shorter string is the pattern to avoid negative edit distances    
    if (length($string1) < length($string2)){
        $string=$string2;
        $pattern=$string1;
    } else {
	$string=$string1;
        $pattern=$string2;
    }
    my $edit_distance=adist($pattern,$string);
    return $edit_distance;
}



# checking stuff
################################################################################
sub analyze_user_line {
    my ($line,$file_abs,$filename,$school,$count,$enc_used,$injected,$type) = @_;
    # $type is USER_FILE or CLASS_FILE
    if ($line=~m/^#/ or $line=~m/^\s*$/){
        # begins with #
        # or contains only whitespace
        return 0;
    } else {
        my $line_raw=$line;
        chomp($line);
        my $semikolon_count=$line=~tr/;//;
        if ($semikolon_count<3){
            print "\n";
            if ($injected eq "yes"){
               print "ERROR: Not 3 semicolons in option: $line\n";
               print "       Example: --injectlie \"students.csv:7a;Darwin;Charles;12.02.1809;\"\n";
            } else {
               print "ERROR: Not 3 semicolons in $line\n";
               print " File: $file_abs\n";
            }
            exit;
        }
        $line=&remove_whitespace($line);
        # add trailing ; if not there
        if (not $line=~m/;$/){
            $line=$line.";";
        }
        my ($class_raw,
            $last_raw,
            $first_raw,
            $birthdate_raw,
            $field5,
            $field6,
           )=split(/;/,$line);

        my ($class_valid,$class,$error_strg_class)=&check_class($class_raw,$filename,$type);
        if ($class_valid==0){
            print REPORT "\nERROR in $line\n";
            print REPORT "   * Class $class_raw not valid ($error_strg_class)\n";
            # ignore the line, as if it is not there
            print ERRORFILE $filename.":".$line_raw;
            return;
        }

        # givenname
        my ($first_valid,$first,$error_strg_first)=&check_first($first_raw);
        if ($first_valid==0){
            print REPORT "\nERROR in $line\n";
            print REPORT "   * Surname $first_raw not valid ($error_strg_first)\n";
            # ignore the line, as if it is not there
            print ERRORFILE $filename.":".$line_raw;
            return;
        }

        # surname
        my ($last_valid,$last,$error_strg_last)=&check_last($last_raw);
        if ($last_valid==0){
            print REPORT "\nERROR in $line\n";
            print REPORT "   * Surname $last_raw not valid ($error_strg_last)\n";
            # ignore the line, as if it is not there
            print ERRORFILE $filename.":".$line_raw;
            return;
        }

        # Birthdate
        my ($birthdate_valid,$birthdate,$error_strg_birth)=&check_birthdate($birthdate_raw);
        if ($birthdate_valid==0){
            print REPORT "\nERROR in $line\n";
            print REPORT "   * Birthdate $birthdate_raw not valid ($error_strg_birth)\n";
            # ignore the line, as if it is not there
            print ERRORFILE $filename.":".$line_raw;
            return;
        }

        my $unid="";
        my $login="";
        # field5
        my $field5_key=$sophomorix_config{'FILES'}{$type}{$filename}{'FIELD_5'};
        if ($field5_key eq "LOGIN"){
            if (defined $field6){
                $login=&check_login($field5);
            }
        } elsif ($field5_key eq "UNID"){
            if (defined $field6){
                $unid=&check_unid($field5);
            }
        }
        # field6
        my $field6_key=$sophomorix_config{'FILES'}{$type}{$filename}{'FIELD_6'};
        if ($field6_key eq "LOGIN"){
            if (defined $field6){
                $login=&check_login($field6);
            }
        } elsif ($field6_key eq "UNID"){
            if (defined $field6){
                $unid=&check_unid($field6);
            }
        }
        if ($unid eq ""){
	    $unid="---";
        }
        if ($unid ne "---" and exists $unid_seen{$filename}{$unid}){
            print "\nERROR: Unid $unid is double in $filename\n\n";
            exit;
        } else {
            $unid_seen{$filename}{$unid}="seen";
        }

        if ($login eq ""){
	    $login="---";
        }

        # converting names to utf8 and then to ascii
        my $conv = Text::Iconv->new($enc_used,"utf8");
        my $first_utf8 = $conv->convert($first);
        my $last_utf8 = $conv->convert($last);
        my $first_ascii =&recode_utf8_to_ascii($first_utf8);
        my $last_ascii =&recode_utf8_to_ascii($last_utf8);
        # identifier
        my $identifier_utf8=join(";", ($last_utf8,$first_utf8,$birthdate));
        my $identifier_ascii=join(";", ($last_ascii,$first_ascii,$birthdate));
        # corrected line
        my $line_new=join(";", ($class,$last_utf8,$first_utf8,$birthdate,$unid));
        print USERSUTF8 $line_new."\n";

        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_OLD}=$line;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW}=$line_new;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_ASCII}=$first_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_UTF8}=$first_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_ASCII}=$last_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_UTF8}=$last_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{BIRTHDATE}=$birthdate;
        $users_file{'identifier_ascii'}{$identifier_ascii}{CLASS}=$class;
        $users_file{'identifier_ascii'}{$identifier_ascii}{UNID}=$unid;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LOGIN}=$login;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE}=$filename;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_ASCII}=$identifier_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_UTF8}=$identifier_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}=$count;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE_ABS}=$file_abs;
        $users_file{'identifier_ascii'}{$identifier_ascii}{INJECTED}=$injected;


        # add here more stuff to create sophomorix.add, ...
        $users_file{'identifier_ascii'}{$identifier_ascii}{ROLE}=
            $sophomorix_config{'FILES'}{$type}{$filename}{sophomorixRole};
        $users_file{'identifier_ascii'}{$identifier_ascii}{SCHOOL}=
            $sophomorix_config{'FILES'}{$type}{$filename}{SCHOOL};

        # identifier list
        #push @{ $users_file{'file'}{$filename}{'identifier_list_ascii'} }, $identifier_ascii;
        #push @{ $users_file{'file'}{$filename}{'identifier_list_utf8'} }, $identifier_utf8;

        # identifier hash
        $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii}="files, not matched";
        $Match{'file_dynamic_identifiers_utf8'}{$identifier_utf8}="files, not matched";

        # file -> line
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_ASCII'}=$identifier_ascii;
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_UTF8'}=$identifier_utf8;

        # save for action 
        $Match{'ACTION'}{$line_new}{'identifier_ascii'}=$identifier_ascii;
        $Match{'ACTION'}{$line_new}{'school'}=
            $sophomorix_config{'FILES'}{$type}{$filename}{SCHOOL};
	$Match{'ACTION'}{$line_new}{'birthdate'}=$birthdate;
	$Match{'ACTION'}{$line_new}{'class'}=$class;
	$Match{'ACTION'}{$line_new}{'filename'}=$filename;
	$Match{'ACTION'}{$line_new}{'firstname_ascii'}=$first_ascii;
	$Match{'ACTION'}{$line_new}{'surname_ascii'}=$last_ascii;
	$Match{'ACTION'}{$line_new}{'firstname_utf8'}=$first_utf8;
	$Match{'ACTION'}{$line_new}{'surname_utf8'}=$last_utf8;
	$Match{'ACTION'}{$line_new}{'line_count'}=$count;
        $Match{'ACTION'}{$line_new}{'role'}=
            $sophomorix_config{'FILES'}{$type}{$filename}{sophomorixRole};
	$Match{'ACTION'}{$line_new}{'unid'}=$unid;
	$Match{'ACTION'}{$line_new}{'login'}=$login;
	$Match{'ACTION'}{$line_new}{'inject'}=$injected;

         # list of lines
         push @{ $Match{'lines'} }, $line_new;
    }
}



sub check_class {
    my $class_valid=1;
    my $error_strg="";
    my ($class,$filename,$type)=@_;
    # type is USER_FILE OR CLASS_FILE
    $class=&remove_whitespace($class);
    # convert to small letters
    $class=~tr/A-Z/a-z/; 
    # sternchenklassen filtern ?????
    # klassen filtern ?????

    # replacements in classnames
    $class=~s/\//$DevelConf::replace_slash_with/g;

    if ($class=~/[^a-z0-9-_]/) { 
        $error_strg="special char in class $class";
        $class_valid=0;
    }
    if ($class=~/^[^a-z0-9]/) { 
        $error_strg="$class begins not with a-z or 0-9";
        $class_valid=0;
    }
    
    # test if groupname must be forced (i.e. teachers)
    if ($sophomorix_config{'FILES'}{$type}{$filename}{'FORCE_GROUP'} eq "TRUE"){
        $class=$sophomorix_config{'FILES'}{$type}{$filename}{'FORCE_GROUPNAME'};
    }
    return ($class_valid,$class,$error_strg);
}



sub check_first {
    my $first_valid=1;
    my $error_strg="";
    my ($first)=@_;
    $first=&remove_whitespace($first);
    # allowed ASCII: ;'`-._  (; leads to errors anyway)
    if ($first=~/[!\\"#\$%&()*+,\/:<>=@?\{\}|\^~]/) { 
        $error_strg="special char in given name $first";
        $first_valid=0;
    }
    return ($first_valid,$first,$error_strg);
}



sub check_last {
    my $last_valid=1;
    my $error_strg="";
    my ($last)=@_;
    $last=&remove_whitespace($last);
    # allowed ASCII: ;'`-._  (; leads to errors anyway)
    if ($last=~/[!\\"#\$%&()*+,\/:<>=@?\{\}|\^~]/) { 
        $error_strg="special char in surname $last";
        $last_valid=0;
    }
    return ($last_valid,$last,$error_strg);
}



sub check_birthdate {
    my $birthdate_valid=1;# valid if not found out otherwise
    my $error_strg="";
    my $birthdate_ok="";

    my ($birthdate)=@_;
    $birthdate=&remove_whitespace($birthdate);

    # Test 1
    my $dot_count=$birthdate=~tr/\.//;
    if ($dot_count==2){
        # continue to Test 2
        if($Conf::log_level>=3){
            print " ... $dot_count dots in date found ... OK\n";
	}
    } elsif ($birthdate eq ""){
        $birthdate_valid=0;
        $error_strg="Birthdate is empty";
        return ($birthdate_valid,$birthdate,$error_strg);
    } else {
        $birthdate_valid=0;
        $error_strg="Birthdate does not have 2 dots: $birthdate";
        return ($birthdate_valid,$birthdate,$error_strg);
    }

    # Test 2
    my ($day,$month,$year)=split(/\./,$birthdate);

    # Instead of undefined use empty string
    # this avoids errors
    if (not defined $day){
        $day="";
    }
    if (not defined $month){
        $month="";
    }
    if (not defined $year){
        $year="";
    }

    if (exists $convert_day{$day}){
        $day=$convert_day{$day};
    } else {
        $birthdate_valid=0;
        $error_strg="Day is not valid: $day";
    }

    if (exists $convert_month{$month}){
        $month=$convert_month{$month};
    } else {
        $birthdate_valid=0;
        $error_strg="Month is not valid: $month";
    }

    if (exists $convert_year{$year}){
        $year=$convert_year{$year};
    } else {
        $birthdate_valid=0;
        $error_strg="Year is not valid: $year";
    }

    $birthdate_ok = join(".",($day,$month,$year));
    return ($birthdate_valid,$birthdate_ok,$error_strg);
}



sub check_unid {
    my ($unid)=@_;
    $unid=&remove_whitespace($unid);
    return $unid;
}



sub check_login {
    my ($login)=@_;
    $login=&remove_whitespace($login);
    return $login;
}



# Encoding stuff
################################################################################
sub reading_firstnames {
    foreach my $file_rel ( @DevelConf::enc_firstnames ){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Error: $! $file_abs not found!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # remove spaces oat beginning of line
            if(/^\#/){ # ignore commented lines
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($first,$first_new) = split(/:/);
            $firstnames_data{$enc}{$first}=0;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for encoding: $enc\n";
        }
        close(DATAFILE);
    }
}



sub reading_firstname_errors {
    foreach my $file_rel ( @DevelConf::enc_err_firstnames ){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Error: $! $file_abs not found!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($error,$message) = split(/:/);
            $message=~s/^\s+ //g;
            $firstnames_errors{$enc}{$error}=$message;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for errors: $enc\n";
        }
        close(DATAFILE);
    }
}


sub reading_lastnames {
    foreach my $file_rel ( @DevelConf::enc_lastnames ){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Error: $! $file_abs not found!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($last,$last_new) = split(/:/);
            $lastnames_data{$enc}{$last}=0;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for encoding: $enc\n";
        }
        close(DATAFILE);
    }
}



sub reading_lastname_errors {
    foreach my $file_rel ( @DevelConf::enc_err_lastnames ){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Error: $! $file_abs not found!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($error,$message) = split(/:/);
            $message=~s/^\s+ //g;
            $lastnames_errors{$enc}{$error}=$message;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for errors: $enc\n";
        }
        close(DATAFILE);
    }
}



sub get_encoding {
    my ($filename)=@_;
    my $enc_used;
    my $enc=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING};
    my $enc_force=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_FORCE};
    my $enc_checked=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED};
    &print_title("Encoding results for  $filename");
    print "   * ENCODING:          $enc (configured)\n";
    print "   * ENCODING_FORCE:    $enc_force\n";
    print "   * ENCODING_CHECKED:  $enc_checked\n";

    # misconfigured *.school.conf: exit
    if ($enc eq "ERROR_ENCODING"){
        print "   * Misconfigured ENCODING in configuration file, see \"iconv --list\"\n";
        exit;
    }   
    if ($enc_force eq "ERROR_ENCODING_FORCE"){
        print "   * Misconfigured ENCODING_FORCE in configuration file\n";
        exit;
    }   
 
    # auto setting
    if ($enc eq "auto" and $enc_force eq "no"){
        # auto
        if ($enc_checked eq "unknown"){
            print "   * ENCODING could not be checked automatically\n";
            print "   * Set ENCODING to the desired value and ENCODING_FORCE to \"yes\"\n";
            exit;
        }
        $enc_used=$enc_checked;
    } elsif ($enc ne "auto" and $enc_force eq "no"){
        # auto mismatch configure
        print "   * Misconfigured ENCODING in configuration file and ENCODING_CHECKED do not match\n";
        print "   * Set A) ENCODING_FORCE to \"yes\" if you know better than sophomorix\n";
        print "   *  or B) ENCODING to \"auto\" if you trust sophomorix\n";
        exit;
    } elsif ($enc ne "auto" and $enc_force eq "yes"){
        $enc_used=$enc;
    }

    print "           ---> Using:  $enc_used\n";
    return $enc_used;
}



sub analyze_encoding {
    my ($file,$file_tmp) = @_;
    # $file ist for printout anh path in config hash only
    # $file_tmp will be analyzed
    my $filename = basename($file);
    my $filename_tmp = basename($file_tmp);
    # set all result counters to 0
    foreach my $enc (@encodings_to_check){
        $encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{$enc}=0;
        $encoding_check_results{$file}{'FIRSTNAMES'}{'count_errors'}{$enc}=0;
        $encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{$enc}=0;
        $encoding_check_results{$file}{'LASTNAMES'}{'count_errors'}{$enc}=0;
    }
    $encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{'none'}=0;
    $encoding_check_results{$file}{'FIRSTNAMES'}{'count_errors'}{'none'}=0;
    $encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{'none'}=0;
    $encoding_check_results{$file}{'LASTNAMES'}{'count_errors'}{'none'}=0;
    $encoding_check_results{$file}{'NAMES'}{'RESULT'}="unknown";

    # start to analyze file_tmp
    &Sophomorix::SophomorixBase::print_title("Encode-analyze $filename_tmp");
    open(DATAFILE, "$file_tmp") || 
         die "Error: $! $file_tmp not found!"; 
    my $count=0;
    while (<DATAFILE>){
        $count++;
        chomp();
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }
        if ($_ eq ""){ # ignore empty line
            next;
        }

        ####################################
        if ($show_special_char_lines==1){
            if ($_=~/[^a-zA-Z0-9\-\.;_\/\s]/) { 
                push @special_char_lines, "Line ".$count."   ".$_;
                #$special_char_lines{$count}=$line;
            }
        }

        my $line=$_;
        chomp($line);
        my $semikolon_count=$line=~tr/;//;
        if ($semikolon_count<3){
            print "\n";
            print "   ERROR: Not 3 Semicolons in $line\n";
            print "          File corrupt: $file\n\n";
            exit;
        }
 
        # add trailing ; if not there
        if (not $line=~m/;$/){
            $line=$line.";";
        }
        my ($class,$lastname,$firstname,$date) = split(/;/);

        # firstname
        # split firstname-field into single firstnames
        # split at 'space' and '-'
        $firstname=&remove_whitespace($firstname);
        my @firstnames=split(/[ ,-]/, $firstname); # split for double names
        foreach my $first (@firstnames){
            if ($first=~/[^a-zA-Z\-]/) { 
                # continue with non-standard(~non-ascii) chars
                my $hit_count=0;   
                my $error_count=0; 
                foreach my $enc (@encodings_to_check){
                    my $conv = Text::Iconv->new($enc,"utf8");
                    my $first_utf8 = $conv->convert($first);

                    # check for positive hits (known, valid firstnames)
                    if (exists $firstnames_data{$enc}{$first}){
                        # remember hits
	                push @{ $encoding_check_results{$file}{'FIRSTNAMES'}{'data_hits'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count hits
                        my $old=$encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{$enc}=$new;
                        $hit_count++;
                    }
                    # check for errors
                    if (exists $firstnames_errors{$enc}{$first}){
                        # remember errors
	                push @{ $encoding_check_results{$file}{'FIRSTNAMES'}{'data_errors'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count errors
                        my $old=$encoding_check_results{$file}{'FIRSTNAMES'}{'count_errors'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'FIRSTNAMES'}{'count_errors'}{$enc}=$new;
                        $hit_count++;
                    }
                }
                # non-hits and non-errors (unknown firstnames) 
                if ($hit_count==0 and $error_count==0){
                    # remember unknown names
                    push @{ $encoding_check_results{$file}{'FIRSTNAMES'}{'data_unknown'} }, 
                           { first => "$first", 
                             line => "$_"};
                    # count unknown names
                    my $old=$encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{'none'};
                    my $new=$old+1;
                    $encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{'none'}=$new;
                }
            }
        }


        # lastname
        # split lastname-field into single lastnames
        # split at 'space' and '-'
        $lastname=&remove_whitespace($lastname);
        my @lastnames=split(/[ ,-]/, $lastname); # split for double names
        foreach my $last (@lastnames){
            if ($last=~/[^a-zA-Z\-]/) { 
                # continue with non-standard(~non-ascii) chars
                my $hit_count=0;   
                my $error_count=0; 
                foreach my $enc (@encodings_to_check){
                    my $conv = Text::Iconv->new($enc,"utf8");
                    my $last_utf8 = $conv->convert($last);

                    # check for positive hits (known, valid firstnames)
                    if (exists $lastnames_data{$enc}{$last}){
                        # remember hits
	                push @{ $encoding_check_results{$file}{'LASTNAMES'}{'data_hits'} }, 
                                { last => "$last", 
                                  last_utf8 => "$last_utf8",
                                  line => "$_"};
                        # count hits
                        my $old=$encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{$enc}=$new;
                        $hit_count++;
                    }
                    # check for errors
                    if (exists $lastnames_errors{$enc}{$last}){
                        # remember errors
	                push @{ $encoding_check_results{$file}{'LASTNAMES'}{'data_errors'} }, 
                                { last => "$last", 
                                  last_utf8 => "$last_utf8",
                                  line => "$_"};
                        # count errors
                        my $old=$encoding_check_results{$file}{'LASTNAMES'}{'count_errors'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'LASTNAMES'}{'count_errors'}{$enc}=$new;
                        $hit_count++;
                    }
                }
                # non-hits and non-errors (unknown lastnames) 
                if ($hit_count==0 and $error_count==0){
                    # remember unknown names
                    push @{ $encoding_check_results{$file}{'LASTNAMES'}{'data_unknown'} }, 
                           { last => "$last", 
                             line => "$_"};
                    # count unknown names
                    my $old=$encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{'none'};
                    my $new=$old+1;
                    $encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{'none'}=$new;
                }
            }
        }
    }

    # calculate sum
    my $oldsum=0;
    foreach my $enc (@encodings_to_check){
        my $sum=
            $encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{$enc}+
	    $encoding_check_results{$file}{'FIRSTNAMES'}{'count_errors'}{$enc}+
            $encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{$enc}+
	    $encoding_check_results{$file}{'LASTNAMES'}{'count_errors'}{$enc};
        $encoding_check_results{$file}{'FIRSTNAMES'}{'count_sum'}{$enc}=$sum;
        if($sum > $oldsum){
            $encoding_check_results{$file}{'NAMES'}{'RESULT'}=$enc;
        }
    }
    # save result in config hash
    $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED}=
        $encoding_check_results{$file}{'NAMES'}{'RESULT'};
    if($Conf::log_level>=2){
        print "$file_tmp --> $encoding_check_results{$file}{'NAMES'}{'RESULT'}\n";
    }
    return $encoding_check_results{$file}{'NAMES'}{'RESULT'};
}



sub print_analyzed_encoding {
    my ($file) = @_;
    print "\nEncoding check result for:\n";
    print "   $file\n";

    # print valid firstnames
    if($Conf::log_level>=2){
    print "\nValid firstnames: ",
          "($encoding_check_results{$file}{'NAMES'}{'RESULT'} ---> utf8)\n";
    print "==========================================================================\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'FIRSTNAMES'}{'data_hits'} } ){
        printf  "%-20s %-12s %-20s\n",
                $item->{first},
                "--->",
                $item->{first_utf8};
    }
    print "--------------------------------------------------------------------------\n";
    }

    # print unknown firstnames
    print "\n";
    print "Unknown firstnames (Please report to info\@linuxmuster.net):\n";
    print "+------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'FIRSTNAMES'}{'data_unknown'} } ){
        printf  "| %-40s |\n",
                $item->{first},
    }
    print "+------------------------------------------+\n";

    #  print firstnames with errors
    print "\nFirstnames that should be an error (Please report the the School Office):\n";
    print "+---------------------------------------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'FIRSTNAMES'}{'data_errors'} } ){
        printf  "| %-15s%-60s|\n",
                $item->{first_utf8},
                $item->{line};
        my $enc_result=$encoding_check_results{$file}{'NAMES'}{'RESULT'};
        printf  "|          ---> %-60s|\n",$firstnames_errors{$enc_result}{ $item->{first} };
        print "+---------------------------------------------------------------------------+\n";
    }

    # print unknown lastnames
    print "\n";
    print "Unknown lastnames (Please report to info\@linuxmuster.net):\n";
    print "+------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'LASTNAMES'}{'data_unknown'} } ){
        printf  "| %-40s |\n",
                $item->{last},
    }
    print "+------------------------------------------+\n";

    #  print lastnames with errors
    print "\nLastnames that should be an error (Please report the the School Office):\n";
    print "+---------------------------------------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'LASTNAMES'}{'data_errors'} } ){
        printf  "| %-15s%-60s|\n",
                $item->{last_utf8},
                $item->{line};
        my $enc_result=$encoding_check_results{$file}{'NAMES'}{'RESULT'};
        printf  "|          ---> %-60s|\n",$lastnames_errors{$enc_result}{ $item->{last} };
        print "+---------------------------------------------------------------------------+\n";
    }

    # print debug dump
    if($Conf::log_level>=3){
        print "Dump of \%encoding_check_results:\n";
        print Dumper(\%encoding_check_results);
    }

    # Print Result
    print "\n";
    print "                      +-----------------+-----------------+         \n";
    print "                      |    firstname    |     surname     |         \n";
    print "+---------------------+--------+--------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |%7s |%7s |\n",
            "Tested Encodings:",
            "Hits",
            "Errors",
            "Hits",
            "Errors",
            "Sum";
    print "+---------------------+--------+--------+--------+--------+--------+\n";
    foreach my $enc (@encodings_to_check){
        printf  "| %-20s|%7s |%7s |%7s |%7s |%7s |\n",
                $enc,
                $encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{$enc},
                $encoding_check_results{$file}{'FIRSTNAMES'}{'count_errors'}{$enc},
                $encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{$enc},
                $encoding_check_results{$file}{'LASTNAMES'}{'count_errors'}{$enc},
   	        $encoding_check_results{$file}{'FIRSTNAMES'}{'count_sum'}{$enc};# ?????????
    }
    print "+---------------------+--------+--------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |%7s |%7s |\n",
            "none of the above",
            $encoding_check_results{$file}{'FIRSTNAMES'}{'count_hits'}{'none'},
            "-",
            $encoding_check_results{$file}{'LASTNAMES'}{'count_hits'}{'none'},
            "-",
            "-";
    print "+---------------------+--------+--------+--------+--------+--------+\n";
    print "$file:\n",
          "    File-Encoding is $encoding_check_results{$file}{'NAMES'}{'RESULT'}\n"; 
    print "\n";
    close(DATAFILE);
}
