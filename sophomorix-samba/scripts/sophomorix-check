#!/usr/bin/perl -w
# This script (sophomorix-check) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@linuxmuster.net

# Bibliotheken
use strict;
#use Quota;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use List::MoreUtils qw(uniq);
use String::Approx 'amatch';
use String::Approx 'adist';
use Net::LDAP;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Useqq = 1;
$Data::Dumper::Terse = 1; 
use JSON;
use File::Basename qw( basename
                       dirname
                     ); 
use Text::Iconv;
use Sophomorix::SophomorixBase qw(
                                 print_line
                                 print_title
                                 time_stamp_AD
                                 time_stamp_file
                                 ymdhms_to_epoch
                                 unlock_sophomorix
                                 lock_sophomorix
                                 log_script_start
                                 log_script_end
                                 log_script_exit
                                 backup_amku_file
                                 get_passwd_charlist
                                 get_plain_password
                                 check_options
                                 config_sophomorix_read
                                 filelist_fetch
                                 remove_whitespace
                                 json_dump
                                 recode_utf8_to_ascii
                                 );
use Sophomorix::SophomorixSambaAD qw(
                                 AD_school_create
                                 AD_bind_admin
                                 AD_unbind_admin
                                 AD_user_create
                                 AD_group_create
                                 AD_group_addmember
                                 AD_group_update
                                 AD_get_schoolname
                                 AD_get_name_tokened
                                 AD_dn_fetch_multivalue
                                 AD_get_AD
                                 AD_dns_get
                                 AD_object_search
                                 get_forbidden_logins
                                    );

my @arguments = @ARGV;

my $time_stamp_file=&time_stamp_file();
my $time_stamp_AD=&time_stamp_AD();
my $time_stamp_epoch=time;
my $user_count=0;

my $school="";
my %users_file=();

# allowed numbers for days
my %convert_day = qw(
     1     01          01    01
     2     02          02    02
     3     03          03    03
     4     04          04    04
     5     05          05    05
     6     06          06    06
     7     07          07    07
     8     08          08    08
     9     09          09    09
     10    10          11    11
     12    12          13    13
     14    14          15    15
     16    16          17    17
     18    18          19    19
     20    20          21    21
     22    22          23    23
     24    24          25    25
     26    26          27    27
     28    28          29    29
     30    30          31    31
);

# allowed numbers for months
my %convert_month = qw(
     1     01          01    01
     2     02          02    02
     3     03          03    03
     4     04          04    04
     5     05          05    05
     6     06          06    06
     7     07          07    07
     8     08          08    08
     9     09          09    09
     10    10          11    11
     12    12
);




# encoding tests
my %firstnames_data=();
my %firstnames_errors=();
my %encoding_check_results=();
my @encodings_to_check=("UTF8","ISO_8859-1");

my @loglines=();

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Variablen für Optionen
$Conf::log_level=1;
my $help=0;
my $info=0;
my %Match=();
my $json=0;
my $dump_matches=0;
my $dump_files=0;
my $dump_AD=0;
my $list_files=0;
my $lock=0;
my $unlock=0;
my $analyze_encoding="";
my $show_special_char_lines=0;
my $non_umlaut=0;
my @special_char_lines=();
my $follow="";
my @injectlines=(); # list of injected lines

# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$Conf::log_level,
           "info|i" => \$info,
           "dump-files" => \$dump_files,
           "dump-AD" => \$dump_AD,
           "dump-matches" => \$dump_matches,
           "json|j+" => \$json,
           "list-files" => \$list_files,
           "lock" => \$lock,
           "analyze-encoding=s" => \$analyze_encoding,
           "follow=s" => \$follow,
           "unlock" => \$unlock,
           "injectline=s" => \@injectlines,
           "show-special-char-lines" => \$show_special_char_lines,
           "non-umlaut|nonumlaut" => \$non_umlaut,
           "help|h" => \$help,
          );


# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);

# --follow
my $follow_file="";
my $follow_line="";
if ($follow ne ""){
    ($follow_file,$follow_line)=split(/:/,$follow);
}

# Reading Configuration
my ($ldap,$root_dse) = &AD_bind_admin();
my $root_dns=&AD_dns_get($root_dse);
my %sophomorix_config=&config_sophomorix_read($ldap,$root_dse);
my @filelist=&filelist_fetch({filetype=>"users",
                              sophomorix_config=>\%sophomorix_config,
                            });

# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print('
sophomorix-check checks the configured user files and finds out which users should be added, updated, moved and killed


Options:
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info

  --list-files                     (list processed files and exit)
  --lock / --unlock

  --follow filename:linenumber     (show what happens to this line)

Analyze the encoding of a file:
  --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show Umlaut and other special chars
  --show-special-char-lines --analyze-encoding /path/to/students.csv
Analyze the encoding of a file and show special chars (not umlauts)
  --non-umlaut  --show-special-char-lines --analyze-encoding /path/to/students.csv

Usable encodings in school.conf:
   iconv -l

Dumping data:                     
  -ij / --info --json              (dump configuration)
  --dump-files -j                  (dump contents of user files)
  --dump-AD -j                     (dump AD data)
  --dump-matches -j                (dump matched users)

  -j / --json                      (dump as a nice json object)
  -jj / --json --json              (dump as a compact json object)
  -jjj / --json --json --json      (dump as a perl hash)

Injecting lines (repeat the option to inject multiple lines):                     
  --injectline "teachers.csv:7a;Meier;Richard;23.09.1996;mue999"
  --injectline "bsz.students.csv:7b;Schmid;Richard;26.04.1995;"
 
Please see the sophomorix-check(8) man pages for full documentation
');
   print "\n";
   exit;
}


# --unlock
if ($unlock==1) {
    &unlock_sophomorix();
    exit;
}


# --lock
if ($lock==1) {
    &lock_sophomorix("lock",0,@arguments);
    exit;
}


# --info
if ($info==1) {
    &json_dump({json => $json,
                jsoninfo => "CONFIG",
                jsoncomment => "The sophomorix configuration",
                hash_ref=>\%sophomorix_config,
               });
    print "\n";
    &print_title("Reading the following user files:");
    foreach my $file (@filelist){
        print "   * $file\n";
    }
    exit;
}


# --list-files
if ($list_files==1) {

       &print_title("Reading the following user files:");
       foreach my $file (@filelist){
           print "   * $file\n";
       }
       exit;
   }


# --analyze-encoding
# analyze one file
if ($analyze_encoding ne ""){
    if($Conf::log_level>=3){
        print "\n";
        print "Analyzing encoding\n";
    }
    &reading_firstnames();
    &reading_firstname_errors();
    my $enc=&analyze_encoding($analyze_encoding,$analyze_encoding);
    if ($show_special_char_lines==1){
        my $count=0;
	foreach my $line (@special_char_lines){
            my $conv = Text::Iconv->new($enc,"utf8");
            my $line_utf8 = $conv->convert($line);
            if ($non_umlaut==1){
                # äöüÄÖÜß works because its unicode
                if ($line_utf8=~/[^äöüÄÖÜßa-zA-Z0-9\-\.;_\/\s]/) { 
                    $count++;
                    print "$count)  $line_utf8\n";
                }
            } else {
                    $count++;
                    print "$count)  $line_utf8\n";
            }
        }
    }
    &print_analyzed_encoding($analyze_encoding);
    &log_script_exit("",1,1,0,@arguments);
}

&log_script_start(@arguments);


################################################################################
# Start
################################################################################




# ============================================================
# analyzing encoding of all filtered user files in tmp
# ============================================================
&reading_firstnames();
&reading_firstname_errors();
foreach my  $user_file (@filelist){
    &analyze_encoding($user_file,$user_file);
}



my $count=0;
# ============================================================
# reading and checking all filtered user files
# ============================================================
system("mkdir -p $DevelConf::path_conf_tmp");
foreach my $user_file (@filelist){
    my $filename = basename($user_file);
    my $user_file_utf8=$DevelConf::path_conf_tmp."/".$filename.".utf8";

    # fetching some config data
    $school=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'};

    my $enc_used=&get_encoding($filename);
    &print_title("Reading $user_file");
    open(USERS,"$user_file") || 
         die "ERROR: $user_file not found!";  
    open(USERSUTF8,">$user_file_utf8") || 
         die "ERROR: $user_file_utf8 not found!";  
    while(<USERS>){
        $count++;
        my $line=$_;
        &analyze_user_line($line,$user_file,$filename,$school,$count,$enc_used,"no");
    }
    close(USERS);
    close(USERSUTF8);
}



# ============================================================
# injecing lines given by option
# ============================================================
&print_title("Reading injected lines ...");
foreach my $inject (@injectlines){
    print "    * $inject\n";
    my ($filename,$line)=split(/:/,$inject,2); # split in 2 parts
    if (exists $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'}){
        $school=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'SCHOOL'};
        print "        file:   $filename\n";
        print "        school: $school\n";
        print "        line:   $line\n";
        $count++;
        my $file_abs=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{'PATH_ABS'};
        # opening the output file to APPEND entries
        my $user_file_utf8=$DevelConf::path_conf_tmp."/".$filename.".utf8";
        open(USERSUTF8,">>$user_file_utf8") || 
             die "ERROR: $user_file_utf8 not found!";  
        &analyze_user_line($line,$file_abs,$filename,$school,$count,"utf8","yes");
        close(USERSUTF8);
    } else {
        print "        WARNING: $filename is not valid on this ",
              "server (skipping this line)\n";
    }
}



# --dump-files
if ($dump_files==1){
    &json_dump({json => $json,
                jsoninfo => "USERS",
                jsoncomment => "All users read from all user files",
                hash_ref=>\%users_file,
               });
}



# --follow
# show the line
if ($follow ne ""){
    my $identifier=$users_file{'file'}{$follow_file}{$follow_line}{'identifier_ascii'};
    if (not defined $identifier){
        print "   * Line $follow_line in file $follow_file contains no usable data\n";
    } else {
        print "   * LINE ORIG: $users_file{'identifier_ascii'}{$identifier}{LINE_OLD}\n";
        print "   * LINE UTF8: $users_file{'identifier_ascii'}{$identifier}{LINE_NEW}\n";
    }
}



# ============================================================
# asking AD for users
# ============================================================
&print_title("Asking the system for users ...");
# fetch system data
my ($ref_AD) = &AD_get_AD({ldap=>$ldap,
                           root_dse=>$root_dse,
                           root_dns=>$root_dns,
                           computers=>"FALSE",
                           rooms=>"FALSE",
                           administratorclasses=>"TRUE",
#                           examaccounts=>"TRUE",
                           users=>"TRUE",
                           dnszones=>"FALSE",
                           dnsnodes=>"FALSE",
             });
my %AD= %$ref_AD; 



# --dump-AD
if ($dump_AD==1){
    &json_dump({json => $json,
                jsoninfo => "SEARCH",
                jsoncomment => "AD Content",
                hash_ref=>\%AD,
              });
}


# ============================================================
# Find Matches: Walk thhrough all files and identifiers in %users_file
# ============================================================

# dynamic matching data ist contained in %Match
# reading user files populate these subhashes (file identifiers):
# $Match{'file_dynamic_identifiers_ascii'} or $users_file{'file_dynamic_identifiers_utf8'}
# and populated from AD by subs (AD identifiers): 
# $Match{'ad_dynamic_identifiers_ascii'} $Match{'ad_dynamic_identifiers_utf8'}

# no migration
#&populate_ad_dynamic_identifiers_utf8();

# migration
&populate_ad_dynamic_identifiers_ascii();

# find exact matches
&find_migration_unid_matches();
&find_migration_ascii_matches();

# find approx matches
# create loop that stopps itself???
&find_migration_ascii_approx_matches(1);
&find_migration_ascii_approx_matches(2);
&find_migration_ascii_approx_matches(3);
&find_migration_ascii_approx_matches(4);

# marriage, birthdate, ... and such matches ???

# check if this is so:
# track approx number with matches 



# --dump-matches
if ($dump_matches==1){
    &json_dump({json => $json,
                jsoninfo => "MATCH",
                jsoncomment => "File user -> AD matches",
                hash_ref=>\%Match,
              });
}



# ============================================================
# Write results into files
# ============================================================

# write into files
#   - go through matches lines in line order
#####################################
#   - check for each matched line:
#     - compare ldap entries, class and school
#      - write to:
#        - sophomorix.nochange -> do nothing, just for information
#        - sophomorix.update   -> update ldap-data and status (+times, if not current)
#        - sophomorix.move     -> move to another class or school
#####################################
#   - unmatched line:
#     - new user: write sophomorix.add
#####################################
#   - unmatched user in ldap:
#     - sophomorix.update mit status und time
#     - sophomorix.kill (if status and times say so)

my $add_file_new=$DevelConf::path_result."/sophomorix.add";
open (ADD, ">$add_file_new");
my $update_file_new=$DevelConf::path_result."/sophomorix.update";
open (UPDATE, ">$update_file_new");
my $move_file_new=$DevelConf::path_result."/sophomorix.move";
open (MOVE, ">$move_file_new");
my $kill_file_new=$DevelConf::path_result."/sophomorix.kill";
open (KILL, ">$kill_file_new");
my $nochange_file_new=$DevelConf::path_result."/sophomorix.nochange";
open (NOCHANGE, ">$nochange_file_new");

&print_title("Writing the files:");


# ADD
############################################################
foreach my $line_new ( @{ $Match{'lines'} } ){
    if (not defined $Match{'action'}{$line_new}{'sAMAccountName'}){
        &write_add_file($line_new);
    }
}

# UPDATE or NOCHANGE
############################################################
foreach my $sam ( keys %{$AD{'sam'}} ) {
    my $update=0; # if > 0 write to sophomorix-update, else sophomorix.nochange
    my $new_status="---";
    my $new_unid="---";
    my $new_surname_ascii="---";
    my $new_firstname_ascii="---";
    my $new_surname_utf8="---";
    my $new_firstname_utf8="---";
    my $new_birthdate="---";
    my $new_filename="---";
    my $new_school="---";
    my $new_role="---";

    ##################################################
    # check status
    &test_UEAS_T_update($sam,\$update,\$new_status);
    &test_T_DA_update($sam,\$update,\$new_status);
    &test_DL_RA_update($sam,\$update,\$new_status);
    &test_R_A_update($sam,\$update,\$new_status);
    print "nEW:   * $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> $new_status ($update)\n";
    ##################################################
    # check identifier update
    if (exists $Match{'action_by_sam'}{$sam}){
        #my $line_new=$Match{'action_by_sam'}{$sam};
        &test_user_update($sam,
                          \$update,
                          \$new_unid,
                          \$new_surname_ascii,
                          \$new_firstname_ascii,
                          \$new_surname_utf8,
                          \$new_firstname_utf8,
                          \$new_birthdate,
                          \$new_filename,
                          \$new_school,
                          \$new_role);
    }
    if ($update>0){
        # things to update
        my $update_line=$sam."::".
                        $new_unid."::".
                        $new_surname_ascii."::".
                        $new_firstname_ascii."::".
                        $new_birthdate."::".
                        $new_surname_utf8."::".
                        $new_firstname_utf8."::".
                        $new_filename."::".
                        $new_status."::".
                        $new_school."::".
                        $new_role."::".
                        "\n";
        print UPDATE $update_line;
    } else {
        # nothing to update
        print NOCHANGE "$sam\n";
    }
}

# KILL
############################################################
&write_kill_file();

close(ADD);
close(UPDATE);
close(MOVE);
close(KILL);
close(NOCHANGE);

&AD_unbind_admin($ldap);
&log_script_end(@arguments);


################################################################################
# Sub
################################################################################

# test status updates
################################################################################
sub test_UEAS_T_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $AD{'sam'}{$sam}{'sophomorixStatus'} eq "U" or
             $AD{'sam'}{$sam}{'sophomorixStatus'} eq "E" or
             $AD{'sam'}{$sam}{'sophomorixStatus'} eq "A" or
             $AD{'sam'}{$sam}{'sophomorixStatus'} eq "S"
           ){
            # update to T if not matched to a user in files
            if (not exists $Match{'action_by_sam'}{$sam}){
                print "   * $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> T\n";
                ${$new_status_ref}="T";
                ${$update_ref}++;
            }
    }
}


sub test_T_DA_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $AD{'sam'}{$sam}{'sophomorixStatus'} eq "T"){
        print "* Testing $sam: $AD{'sam'}{$sam}{'sophomorixStatus'},",
               " TolerationDate: $AD{'sam'}{$sam}{'sophomorixTolerationDate'}\n";
        my $file=$AD{'sam'}{$sam}{'sophomorixAdminFile'};
        my $toleration_date_epoch=&ymdhms_to_epoch($AD{'sam'}{$sam}{'sophomorixTolerationDate'});
        my $toleration_end_epoch=$toleration_date_epoch+
            86400*$sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'TOLERATION_TIME'};
        print "    Toleration end: $toleration_end_epoch ($AD{'sam'}{$sam}{'sophomorixTolerationDate'}",
              " + $sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'TOLERATION_TIME'} days)\n";
        print "    Today:          $time_stamp_epoch\n";
        if (not exists $Match{'action_by_sam'}{$sam} and 
            $time_stamp_epoch > $toleration_end_epoch){
            # update to D if 
            #     - not matched to a user in files
            #     - and toleration time expired
            print "    ----> $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> D\n";
            ${$new_status_ref}="D";
            ${$update_ref}++;
	} elsif (exists $Match{'action_by_sam'}{$sam}){
            # update to A if 
            #     - matched to a user in files
            print "    ----> $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> A\n";
            ${$new_status_ref}="A";
            ${$update_ref}++;
	} else {
            # do nothing
            print "    ----> Toleration end not reached\n";
        }
    }
}


sub test_DL_RA_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $AD{'sam'}{$sam}{'sophomorixStatus'} eq "D" or
        $AD{'sam'}{$sam}{'sophomorixStatus'} eq "L"
       ){
        print "* Testing $sam: $AD{'sam'}{$sam}{'sophomorixStatus'},",
              " DeactivationDate: $AD{'sam'}{$sam}{'sophomorixDeactivationDate'}\n";
        my $file=$AD{'sam'}{$sam}{'sophomorixAdminFile'};
        my $deactivation_date_epoch=&ymdhms_to_epoch($AD{'sam'}{$sam}{'sophomorixDeactivationDate'});
        my $deactivation_end_epoch=$deactivation_date_epoch+
            86400*$sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'DEACTIVATION_TIME'};
            
        print "    Deactivation end: $deactivation_end_epoch ($AD{'sam'}{$sam}{'sophomorixDeactivationDate'}",
              " + $sophomorix_config{'FILES'}{'USER_FILE'}{$file}{'DEACTIVATION_TIME'} days)\n";
        print "    Today:            $time_stamp_epoch\n";
        ########################################
        if (not exists $Match{'action_by_sam'}{$sam} and 
            $time_stamp_epoch > $deactivation_end_epoch){
            # update to R/put in kill-file  if 
            #     - not matched to a user in files
            #     - and deactivation time expired
            # 1) update status to R
            print "    ----> $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> R\n";
            ${$new_status_ref}="R";
            ${$update_ref}++;
            # 2) put user in kill file
            print "    ----> $sam is put into kill file\n";
            # calculation school name
            my $school;
            if ($AD{'sam'}{$sam}{'sophomorixSchoolname'} eq 
                $DevelConf::name_default_school){
                $school="---";
	    } else {
                $school=$AD{'sam'}{$sam}{'sophomorixSchoolname'};
            }
            # creating the line
            my $kill_line=
                $AD{'sam'}{$sam}{'IDENTIFIER_ASCII'}."::".
                $sam."::".
                $AD{'sam'}{$sam}{'sophomorixAdminClass'}."::".
                $school."::\n";               
            print KILL $kill_line;
        } elsif (exists $Match{'action_by_sam'}{$sam} and 
            $AD{'sam'}{$sam}{'sophomorixStatus'} eq "D"){
            # update to A if 
            #     - matched to a user in files
            #     - old status is D (not for status L)
            print "    ----> $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> A\n";
            ${$new_status_ref}="A";
            ${$update_ref}++;
        ########################################
	} else {
            print "    ----> Deactivation end not reached\n";
        }
     }
}


sub test_R_A_update{
    my ($sam,$update_ref,$new_status_ref)=@_;
    if ( $AD{'sam'}{$sam}{'sophomorixStatus'} eq "R" and 
        exists $Match{'action_by_sam'}{$sam} 
       ){
        # update R to A if 
        #     - matched to a user in files
        print "    ----> $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> A\n";
        ${$new_status_ref}="A";
        ${$update_ref}++;
    }
}



# test user update
################################################################################
sub test_user_update {
    my ($sam,
        $update_ref,
        $unid_ref,
        $surname_ascii_ref,
        $firstname_ascii_ref,
        $surname_utf8_ref,
        $firstname_utf8_ref,
        $birthdate_ref,
        $filename_ref,
        $school_ref,
        $role_ref,
       )=@_;
    my $line_new=$Match{'action_by_sam'}{$sam};

    # unid
    if ( ($Match{'action'}{$line_new}{'unid'} eq $AD{'sam'}{$sam}{'sophomorixUnid'}) or
         ($Match{'action'}{$line_new}{'unid'} eq "" and $AD{'sam'}{$sam}{'sophomorixUnid'} eq "---") ){
        # no update
        ${$unid_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$unid_ref}=$Match{'action'}{$line_new}{'unid'};
    }

    # surname_ascii
    if ( ($Match{'action'}{$line_new}{'surname_ascii'} eq $AD{'sam'}{$sam}{'sophomorixSurnameASCII'})){
        # no update
        ${$surname_ascii_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$surname_ascii_ref}=$Match{'action'}{$line_new}{'surname_ascii'};
    }

    # firstname_ascii
    if ( ($Match{'action'}{$line_new}{'firstname_ascii'} eq $AD{'sam'}{$sam}{'sophomorixFirstnameASCII'} )){
        # no update
        ${$firstname_ascii_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$firstname_ascii_ref}=$Match{'action'}{$line_new}{'firstname_ascii'};
    }

    # firstname_utf8 and surname_utf8
    if ( ($Match{'action'}{$line_new}{'firstname_utf8'} ne $AD{'sam'}{$sam}{'givenName'}) or
         ($Match{'action'}{$line_new}{'surname_utf8'} ne $AD{'sam'}{$sam}{'sn'}) ){
        ${$update_ref}++;
        ${$firstname_utf8_ref}=$Match{'action'}{$line_new}{'firstname_utf8'};
        ${$surname_utf8_ref}=$Match{'action'}{$line_new}{'surname_utf8'};
    } else {
        # no update
        ${$firstname_utf8_ref}="---";
        ${$surname_utf8_ref}="---";
    }

    # birthdate
    if ( ($Match{'action'}{$line_new}{'birthdate'} eq $AD{'sam'}{$sam}{'sophomorixBirthdate'} )){
        # no update
        ${$birthdate_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$birthdate_ref}=$Match{'action'}{$line_new}{'birthdate'};
    }

    # filename
    if ( ($Match{'action'}{$line_new}{'filename'} eq $AD{'sam'}{$sam}{'sophomorixAdminFile'} )){
        # no update
        ${$filename_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$filename_ref}=$Match{'action'}{$line_new}{'filename'};
    }

    # school
    if ( ($Match{'action'}{$line_new}{'school'} eq $AD{'sam'}{$sam}{'sophomorixSchoolname'} )){
        # no update
        ${$school_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$school_ref}=$Match{'action'}{$line_new}{'school'};
    }

    # role
    if ( ($Match{'action'}{$line_new}{'role'} eq $AD{'sam'}{$sam}{'sophomorixRole'} )){
        # no update
        ${$role_ref}="---";
    } else {
        # update
        ${$update_ref}++;
        ${$role_ref}=$Match{'action'}{$line_new}{'role'};
    }
}



# writing lines into files
################################################################################
sub write_add_file {
    my ($line_new)=@_;
    if($Conf::log_level>=2){
        print "$line_new\n";
        print "   * not matched to any sAMAccountName\n";
    }
    my $status;
    if ($Match{'action'}{$line_new}{'inject'} eq "yes"){
        $status="S"; # injected users have status S=selfactivated
    } else {
        $status="U";
    }
    my $add_line=$Match{'action'}{$line_new}{'filename'}."::".
                 $Match{'action'}{$line_new}{'class'}."::".
                 $Match{'action'}{$line_new}{'identifier_ascii'}."::".
                 $Match{'action'}{$line_new}{'login'}."::".
                 "---::". # firstpassword
                 "---::". # uid
                 "---::". # gid
                 $Match{'action'}{$line_new}{'unid'}."::".
                 $Match{'action'}{$line_new}{'school'}."::".
                 $Match{'action'}{$line_new}{'role'}."::".
                 $Match{'action'}{$line_new}{'surname_utf8'}."::".
                 $Match{'action'}{$line_new}{'firstname_utf8'}."::".
                 $status."::".   # status
                 "---::". # creationdate
                 "---::". # tolerationdate
                 "---::". # deactivationdate
                 "---::". # sambantpassword
                 "---::". # userpassword
                 "\n";

    print ADD $add_line;
}



sub write_kill_file {
    # walk through all users
    foreach my $sam ( keys %{$AD{'sam'}} ) {
        if ( $AD{'sam'}{$sam}{'sophomorixStatus'} eq "K" or
             ($AD{'sam'}{$sam}{'sophomorixStatus'} eq "R" and not exists $Match{'action_by_sam'}{$sam})
           ){
            print "    ----> $sam: $AD{'sam'}{$sam}{'sophomorixStatus'} -> sophomorix.kill\n";
            # calculation school name
            my $school;
            if ($AD{'sam'}{$sam}{'sophomorixSchoolname'} eq 
                $DevelConf::name_default_school){
                $school="---";
	    } else {
                $school=$AD{'sam'}{$sam}{'sophomorixSchoolname'};
            }
            # creating the line
            my $kill_line=
               $AD{'sam'}{$sam}{'IDENTIFIER_ASCII'}."::".
               $sam."::".
               $AD{'sam'}{$sam}{'sophomorixAdminClass'}."::".
               $school."::\n";               
            print KILL $kill_line;
        }
    }
}



# UTF8 match
################################################################################
sub populate_ad_dynamic_identifiers_utf8 {
    foreach my $identifier_utf8 (keys %{$AD{'lookup'}{'user_by_identifier_utf8'}} ) { 
        $Match{'ad_dynamic_identifiers_utf8'}{$identifier_utf8}="ad, not matched";
    } 
}



# Migration match
################################################################################
# call this in the end of all matches ??????????????????????ßßß
sub show_dynamic_identifiers_ascii {
    my $file_count=0;
    my $ad_count=0;
    my @file_ids=();
    my @ad_ids=();
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        push @file_ids, $identifier_ascii;
        $file_count++;
    } 
    foreach my $identifier_ascii (keys %{$Match{'ad_dynamic_identifiers_ascii'}} ) {
        push @ad_ids, $identifier_ascii;
        $ad_count++;
    }
    my $diff=$ad_count-$file_count;
    &print_title("$file_count users in files to be matched with $ad_count in AD (Diff: $diff)");
    if ($file_count==0 or $ad_count==0){
	return 0;
    } else {
        if($Conf::log_level>=2){
	    @file_ids= sort @file_ids;
            print "file_dynamic_identifiers_ascii:\n";
            foreach my $id (@file_ids){
                print "   * $id (in files)\n";
            }   
	    @ad_ids = sort @ad_ids;
            print "ad_dynamic_identifiers_ascii:\n";
            foreach my $id (@ad_ids){
                my $status=
                print "   * $id ($AD{'lookup'}{'user_by_identifier_ascii'}{$id} in AD,",
                      " status $AD{'lookup'}{'status_by_identifier_ascii'}{$id})\n";
            }    
        }
        return 1;
    }
}



sub populate_ad_dynamic_identifiers_ascii {
    foreach my $identifier_ascii (keys %{$AD{'lookup'}{'user_by_identifier_ascii'}} ) { 
        $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii}="ad, not matched";
    } 
}



sub find_migration_ascii_approx_matches {
    my ($max_edit_distance) = @_;
    my $run="approx_".$max_edit_distance."_run";
    print "\n";
    &print_title("Migration approx matching (max. edit distance $max_edit_distance)");
    my $ret=&show_dynamic_identifiers_ascii();
    if ($ret==0){
        print "---> Nothing to do anymore\n";
	    return 0;
    }
    my $line_count=0;
    my $matched_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        $line_count++;
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        print " $filename:",
              "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
              "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
              "$identifier_ascii\n";
        my $count=0;
        foreach my $identifier_ascii_ad ( keys %{ $Match{'ad_dynamic_identifiers_ascii'} } ){
            $count++;
            my $edit_distance=&edit_distance($identifier_ascii,$identifier_ascii_ad);
            if($Conf::log_level>=3){
                print "   * $identifier_ascii <---> $identifier_ascii_ad ($count)\n";
                print "      * $edit_distance (Edit distance)\n";
            }
            if ($edit_distance <= $max_edit_distance){
                # APPROX MATCH
                my $sam=$AD{'lookup'}{'user_by_identifier_ascii'}{$identifier_ascii_ad};
                print "   * APPROXMATCH($edit_distance): $identifier_ascii_ad\n";
                delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii_ad};
                # save match to delete this match from list
                $Match{'file_approx_match'}{$run}{$identifier_ascii}=$edit_distance;
                # remove the approx matches from the list
                delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};

                # save to write later
                my $sub=(caller(0))[3];
                my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
                $Match{'action'}{$line_new}{'sAMAccountName'}=$sam;
                $Match{'action'}{$line_new}{'MATCH_SUB'}="$sub $max_edit_distance";
                $Match{'action'}{$line_new}{'status'}=
                    $AD{'lookup'}{'status_by_identifier_ascii'}{$identifier_ascii};
                # reverse action_by_sam
                $Match{'action_by_sam'}{$sam}=$line_new;
            }
        }
    }
    &print_title("Migration approx matching ($line_count tested)");
}



sub find_migration_ascii_matches {
    print "\n";
    &print_title("Migration matching ascii-to-utf8");
    &show_dynamic_identifiers_ascii();
    my $line_count=0;
    my $matched_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        $line_count++;
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        if ( exists $AD{'lookup'}{'user_by_identifier_ascii'}{$identifier_ascii} ){
            # MATCH
            my $sam=$AD{'lookup'}{'user_by_identifier_ascii'}{$identifier_ascii};
            if($Conf::log_level>=2){
                print "    MATCH: $identifier_ascii to $sam\n";
            }

            # save to write later
            my $sub=(caller(0))[3];
            $Match{'file'}{$filename}{$identifier_ascii}=$sam;
            my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
            $Match{'action'}{$line_new}{'sAMAccountName'}=$sam;
            $Match{'action'}{$line_new}{'MATCH_SUB'}="$sub";
            $Match{'action'}{$line_new}{'status'}=
                $AD{'lookup'}{'status_by_identifier_ascii'}{$identifier_ascii};
            # reverse action_by_sam
            $Match{'action_by_sam'}{$sam}=$line_new;

            # remove from ad_to_be_matched
            delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii};
            delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};
            $matched_count++;
        } else {
            # NO MATCH
            print " $filename:",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                  "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                  "$identifier_ascii\n";
            print "   --> No exact match for $identifier_ascii\n";
            $Match{'find_migration_ascii_matches'}{$identifier_ascii}="no exact identifier match possible";
            $not_matched_count++;
        }
    }
    &print_title("ascii--to-utf8-Matching $line_count lines: $matched_count matched, $not_matched_count unmatched");
}



sub find_migration_unid_matches {
    print "\n";
    &print_title("unidMatching lines to accounts:");
    &show_dynamic_identifiers_ascii();
    my $line_count=0;
    my $matched_count=0;
    my $no_unid_count=0;
    my $not_matched_count=0;
    foreach my $identifier_ascii (keys %{$Match{'file_dynamic_identifiers_ascii'}} ) {
        my $filename=$users_file{'identifier_ascii'}{$identifier_ascii}{FILE};
        $line_count++;
        if ($users_file{'identifier_ascii'}{$identifier_ascii}{UNID} ne ""){
            # finding a unid match 
            if ( exists $AD{'lookup'}{'user_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}} and
                 $AD{'lookup'}{'user_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}} ne "---"
               ){
                # MATCH
                my $sam=$AD{'lookup'}{'user_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}};
                my $role=$AD{'lookup'}{'role_by_user'}{$sam};
                # fetch the identifier from AD with same unid
                my $identifier_ascii_from_AD=
		    $AD{'lookup'}{'identifier_ascii_by_unid'}{$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}};
                if($Conf::log_level>=2){
                    print " $filename:",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                          "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                          "$identifier_ascii\n";
	            print "  --> unidMATCH: $sam --> ",
                          "$identifier_ascii_from_AD\n";
                }
                $matched_count++;
                # remove from dynamic hashes
                delete $Match{'ad_dynamic_identifiers_ascii'}{$identifier_ascii_from_AD};
                delete $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii};

                # save to write later
                my $sub=(caller(0))[3];
                $Match{'file'}{$filename}{$identifier_ascii}=$sam;
                my $line_new=$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW};
                $Match{'action'}{$line_new}{'sAMAccountName'}=$sam;
                $Match{'action'}{$line_new}{'MATCH_SUB'}="$sub";
                $Match{'action'}{$line_new}{'status'}=
                    $AD{'lookup'}{'status_by_identifier_ascii'}{$identifier_ascii};
                # reverse action_by_sam
                $Match{'action_by_sam'}{$sam}=$line_new;

            } else {
                # NO MATCH
                $Match{'find_migration_unid_matches'}{$identifier_ascii}="no unid match";
                $not_matched_count++;
                print " $filename:",
                      "$users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}: ",
                      "$users_file{'identifier_ascii'}{$identifier_ascii}{UNID}: ",
                      "$identifier_ascii\n";
                print "   --> Unid $users_file{'identifier_ascii'}{$identifier_ascii}{UNID}",
                      " not found in AD\n";
            }
        } else {
            $no_unid_count++;
            $Match{'find_migration_unid_matches'}{$identifier_ascii}="no unid, no match possible";
        }
    }
    &print_title("unidMatching $line_count lines: $matched_count matched, $not_matched_count unmatched, $no_unid_count without unid");
}



# APPROX stuff
################################################################################
sub edit_distance {
    my ($string1,$string2)=@_;
    my $string;
    my $pattern;
    # the shorter string is the pattern to avoid negative edit distances    
    if (length($string1) < length($string2)){
        $string=$string2;
        $pattern=$string1;
    } else {
	$string=$string1;
        $pattern=$string2;
    }
    my $edit_distance=adist($pattern,$string);
    return $edit_distance;
}



# checking stuff
################################################################################
sub analyze_user_line {
    my ($line,$file_abs,$filename,$school,$count,$enc_used,$injected) = @_;
#    if (m/^#/ or m/^\s*$/){
    if ($line=~m/^#/ or $line=~m/^\s*$/){
        return 0;
    } else {
        chomp($line);
        my ($class_raw,
            $last_raw,
            $first_raw,
            $birthdate_raw,
            $field5,
           )=split(/;/,$line);

        my $class=&check_class($class_raw);
        my $first=&check_first($first_raw);
        my $last=&check_last($last_raw);
        my $birthdate=&check_birthdate($birthdate_raw);
        my $unid="";
        my $login="";
        my $field5_key=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{FIELD5};
        if ($field5_key eq "LOGIN"){
            $login=&check_login($field5);
        } elsif ($field5_key eq "UNID"){
            $unid=&check_unid($field5);
        }
        if ($unid eq ""){
	    $unid="---";
        }
        if ($login eq ""){
	    $login="---";
        }

        # converting names to utf8 and then to ascii
        my $conv = Text::Iconv->new($enc_used,"utf8");
        my $first_utf8 = $conv->convert($first);
        my $last_utf8 = $conv->convert($last);
        my $first_ascii =&recode_utf8_to_ascii($first_utf8);
        my $last_ascii =&recode_utf8_to_ascii($last_utf8);
        # identifier
        my $identifier_utf8=join(";", ($last_utf8,$first_utf8,$birthdate));
        my $identifier_ascii=join(";", ($last_ascii,$first_ascii,$birthdate));
        # corrected line
        my $line_new=join(";", ($class,$last_utf8,$first_utf8,$birthdate,$unid));
        print USERSUTF8 $line_new."\n";

        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_OLD}=$line;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_NEW}=$line_new;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_ASCII}=$first_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FIRSTNAME_UTF8}=$first_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_ASCII}=$last_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LASTNAME_UTF8}=$last_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{BIRTHDATE}=$birthdate;
        $users_file{'identifier_ascii'}{$identifier_ascii}{CLASS}=$class;
        $users_file{'identifier_ascii'}{$identifier_ascii}{UNID}=$unid;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LOGIN}=$login;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE}=$filename;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_ASCII}=$identifier_ascii;
        $users_file{'identifier_ascii'}{$identifier_ascii}{IDENTIFIER_UTF8}=$identifier_utf8;
        $users_file{'identifier_ascii'}{$identifier_ascii}{LINE_COUNT}=$count;
        $users_file{'identifier_ascii'}{$identifier_ascii}{FILE_ABS}=$file_abs;
        $users_file{'identifier_ascii'}{$identifier_ascii}{INJECTED}=$injected;


        # add here more stuff to create sophomorix.add, ...
        $users_file{'identifier_ascii'}{$identifier_ascii}{ROLE}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{RT_sophomorixRole};
        #$users_file{'identifier_ascii'}{$identifier_ascii}{OU}=
        #    $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{OU};
        $users_file{'identifier_ascii'}{$identifier_ascii}{SCHOOL}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{SCHOOL};

        # identifier list
        #push @{ $users_file{'file'}{$filename}{'identifier_list_ascii'} }, $identifier_ascii;
        #push @{ $users_file{'file'}{$filename}{'identifier_list_utf8'} }, $identifier_utf8;

        # identifier hash
        $Match{'file_dynamic_identifiers_ascii'}{$identifier_ascii}="files, not matched";
        $Match{'file_dynamic_identifiers_utf8'}{$identifier_utf8}="files, not matched";

        # file -> line
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_ASCII'}=$identifier_ascii;
        #$users_file{'file'}{$filename}{$count}{'IDENTIFIER_UTF8'}=$identifier_utf8;

        # save for action 
        $Match{'action'}{$line_new}{'identifier_ascii'}=$identifier_ascii;
        $Match{'action'}{$line_new}{'school'}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{SCHOOL};
	$Match{'action'}{$line_new}{'birthdate'}=$birthdate;
	$Match{'action'}{$line_new}{'class'}=$class;
	$Match{'action'}{$line_new}{'filename'}=$filename;
	$Match{'action'}{$line_new}{'firstname_ascii'}=$first_ascii;
	$Match{'action'}{$line_new}{'surname_ascii'}=$last_ascii;
	$Match{'action'}{$line_new}{'firstname_utf8'}=$first_utf8;
	$Match{'action'}{$line_new}{'surname_utf8'}=$last_utf8;
	$Match{'action'}{$line_new}{'line_count'}=$count;
        $Match{'action'}{$line_new}{'role'}=
            $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{RT_sophomorixRole};
	$Match{'action'}{$line_new}{'unid'}=$unid;
	$Match{'action'}{$line_new}{'login'}=$login;
	$Match{'action'}{$line_new}{'inject'}=$injected;

         # list of lines
         push @{ $Match{'lines'} }, $line_new;
    }
}



sub check_class {
    my ($class)=@_;
    $class=&remove_whitespace($class);
    # convert to small letters
    $class=~tr/A-Z/a-z/; 
    # sternchenklassen filtern ?????
    # klassen filtern ?????
    $class=~s/\//$DevelConf::replace_slash_with/g;

    if ($class eq "lehrer" or 
        $class eq "Lehrer"
       ){
        $class=$DevelConf::teacher;
    }
    return $class;
}



sub check_first {
    my ($first)=@_;
    $first=&remove_whitespace($first);
    return $first;
}



sub check_last {
    my ($last)=@_;
    $last=&remove_whitespace($last);
    return $last;
}



sub check_birthdate {
    my ($birthdate)=@_;
    $birthdate=&remove_whitespace($birthdate);
    my $dot_count=$birthdate=~tr/\.//;
    if ($dot_count==2){
        if($Conf::log_level>=3){
            print " ... $dot_count dots in date found ... OK\n";
	}
    } elsif ($birthdate eq ""){
        if($Conf::log_level>=3){
            print " ... Date is empty, Line not corrupted ...\n";
	}
    } else {
	#$datum_korrupt=1;
        print " ... $dot_count dots in date found ... ERROR\n";
	#$datum_korrupt_anzahl++;
          
        # Eintrag in report.admin
        #push (@admin_list_corrupt, "Corrupted Line (" , $punkte_anzahl ,
        #                  " dots in date):\n" , $_ , "\n\n");
        # Set tag for Abbruch
        #$tag = "0"  
    }

    my ($day,$month,$year)=split(/\./,$birthdate);

    $day=$convert_day{$day};
    $month=$convert_month{$month};

    # Instead of undefined use empty string
    # this avoids errors
    if (not defined $day){
        $day="";
    }
    if (not defined $month){
        $month="";
    }
    if (not defined $year){
        $year="";
    }

    my $birthdate_ok = join(".",($day,$month,$year));
    return $birthdate_ok;
}



sub check_unid {
    my ($unid)=@_;
    $unid=&remove_whitespace($unid);
    return $unid;
}



sub check_login {
    my ($login)=@_;
    $login=&remove_whitespace($login);
    return $login;
}



# Encoding stuff
################################################################################
sub reading_firstnames {
    my @datafiles=("firstnames.utf8.txt", 
                   "firstnames.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($first,$first_new) = split(/:/);
            $firstnames_data{$enc}{$first}=0;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for encoding: $enc\n";
        }
        close(DATAFILE);
    }
}



sub reading_firstname_errors {
    my @datafiles=("firstname_errors.utf8.txt", 
                   "firstname_errors.ISO_8859-1.txt", 
                  );
    foreach my $file_rel (@datafiles){
        my $file_abs=${DevelConf::path_encoding_data}."/".$file_rel;
        my @list = split(/\//,$file_abs);
        my $filename = pop @list;
        my ($string1,$enc,$string2)=split(/\./,$filename); 
        open(DATAFILE, "$file_abs") || 
             die "Fehler: $! $file_abs nicht gefunden!"; 
        while (<DATAFILE>){
            chomp();
            s/^ //g; # Leerzeichen am Zeilenangfang entfernen
            if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
               next;
	    }
            if($_ eq ""){
                next;
            }
            my ($error,$message) = split(/:/);
            $message=~s/^\s+ //g;
            $firstnames_errors{$enc}{$error}=$message;
        }
        if($Conf::log_level>=3){
            print "   Reading $file_abs for errors: $enc\n";
        }
        close(DATAFILE);
    }
}



sub get_encoding {
    my ($filename)=@_;
    my $enc_used;
    my $enc=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING};
    my $enc_force=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_FORCE};
    my $enc_checked=$sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED};
    print "   * ENCODING:          $enc\n";
    print "   * ENCODING_FORCE:    $enc_force\n";
    print "   * ENCODING_CHECKED:  $enc_checked\n";

    # misconfigured *.school.conf: exit
    if ($enc eq "ERROR_ENCODING"){
        print "   * Misconfigured ENCODING in configuration file, see \"iconv --list\"\n";
        exit;
    }   
    if ($enc_force eq "ERROR_ENCODING_FORCE"){
        print "   * Misconfigured ENCODING_FORCE in configuration file\n";
        exit;
    }   
 
    # auto setting
    if ($enc eq "auto" and $enc_force eq "no"){
        # auto
        if ($enc_checked eq "unknown"){
            print "   * ENCODING could not be checked automatically\n";
            print "   * Set ENCODING to the desired value and ENCODING_FORCE to \"yes\"\n";
            exit;
        }
        $enc_used=$enc_checked;
    } elsif ($enc ne "auto" and $enc_force eq "no"){
        # auto mismatch configure
        print "   * Misconfigured ENCODING in configuration file and ENCODING_CHECKED do not match\n";
        print "   * Set ENCODING_FORCE to \"yes\" if you know better than sophomorix\n";
        exit;
    } elsif ($enc ne "auto" and $enc_force eq "yes"){
        $enc_used=$enc;
    }

    print "           ---> Using:  $enc_used\n";
    return $enc_used;
}



sub analyze_encoding {
    my ($file,$file_tmp) = @_;
    # $file ist for printout anh path in config hash only
    # $file_tmp will be analyzed
    my $filename = basename($file);
    my $filename_tmp = basename($file_tmp);
    # set all result counters to 0
    foreach my $enc (@encodings_to_check){
        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=0;
        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=0;
    }
    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'count_errors'}{'none'}=0;
    $encoding_check_results{$file}{'firstnames'}{'result'}="unknown";

    # start to analyze file_tmp
    &Sophomorix::SophomorixBase::print_title("Encode-analyze $filename_tmp");
    open(DATAFILE, "$file_tmp") || 
         die "Fehler: $! $file_tmp not found!"; 
    my $count=0;
    while (<DATAFILE>){
        $count++;
        chomp();
        s/^ //g; # Leerzeichen am Zeilenangfang entfernen
        if(/^\#/){ # # am Anfang bedeutet Kommentarzeile
            next;
        }
        if ($_ eq ""){ # ignore empty line
            next;
        }

        ####################################
        if ($show_special_char_lines==1){
            if ($_=~/[^a-zA-Z0-9\-\.;_\/\s]/) { 
                push @special_char_lines, "Line ".$count."   ".$_;
                #$special_char_lines{$count}=$line;
            }
        }
        my ($class,$surname,$firstname,$date) = split(/;/);
        # split firstname-field into single firstnames
        # split at 'space' and '-'
        my @firstnames=split(/[ ,-]/, $firstname);
        foreach my $first (@firstnames){
            if ($first=~/[^a-zA-Z\-]/) { 
                # continue with non-standard(~non-ascii) chars
                my $hit_count=0;   
                my $error_count=0; 
                foreach my $enc (@encodings_to_check){
                    my $conv = Text::Iconv->new($enc,"utf8");
                    my $first_utf8 = $conv->convert($first);

                    # check for positive hits (known, valid firstnames)
                    if (exists $firstnames_data{$enc}{$first}){
                        # remember hits
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count hits
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}=$new;
                        $hit_count++;
                    }
                    # check for errors
                    if (exists $firstnames_errors{$enc}{$first}){
                        # remember errors
	                push @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} }, 
                                { first => "$first", 
                                  first_utf8 => "$first_utf8",
                                  line => "$_"};
                        # count errors
                        my $old=$encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
                        my $new=$old+1;
                        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc}=$new;
                        $hit_count++;
                    }
                }
                # non-hits and non-errors (unknown firstnames) 
                if ($hit_count==0 and $error_count==0){
                    # remember unknown names
                    push @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} }, 
                           { first => "$first", 
                             line => "$_"};
                    # count unknown names
                    my $old=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'};
                    my $new=$old+1;
                    $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'}=$new;
                }
            }
        }
    }

    # calculate sum
    my $oldsum=0;
    foreach my $enc (@encodings_to_check){
        my $sum=$encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc}+
	        $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc};
        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc}=$sum;
        if($sum > $oldsum){
            $encoding_check_results{$file}{'firstnames'}{'result'}=$enc;
        }
    }
    # save result in config hash
    $sophomorix_config{'FILES'}{'USER_FILE'}{$filename}{ENCODING_CHECKED}=
        $encoding_check_results{$file}{'firstnames'}{'result'};
    if($Conf::log_level>=2){
        print "$file_tmp --> $encoding_check_results{$file}{'firstnames'}{'result'}\n";
    }
    return $encoding_check_results{$file}{'firstnames'}{'result'};
}



sub print_analyzed_encoding {
    my ($file) = @_;
    print "\nEncoding check result for:\n";
    print "   $file\n";

    # print valid firstnames
    if($Conf::log_level>=2){
    print "\nValid firstnames: ",
          "($encoding_check_results{$file}{'firstnames'}{'result'} ---> ut8)f\n";
    print "==========================================================================\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_hits'} } ){
        printf  "%-20s %-12s %-20s\n",
                $item->{first},
                "--->",
                $item->{first_utf8};
    }
    print "--------------------------------------------------------------------------\n";
    }

    # print unknown firstnames
    print "\n";
    print "Unknown firstnames (Please report to info\@linuxmuster.net):\n";
    print "+------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_unknown'} } ){
        printf  "| %-40s |\n",
                $item->{first},
    }
    print "+------------------------------------------+\n";

    #  print firstnames with errors
    print "\nFirstnames that should be an error (Please report the the School Office):\n";
    print "+---------------------------------------------------------------------------+\n";
    foreach my $item ( @{ $encoding_check_results{$file}{'firstnames'}{'data_errors'} } ){
        printf  "| %-15s%-60s|\n",
                $item->{first_utf8},
                $item->{line};
        my $enc_result=$encoding_check_results{$file}{'firstnames'}{'result'};
        printf  "|          ---> %-60s|\n",$firstnames_errors{$enc_result}{ $item->{first} };
        print "+---------------------------------------------------------------------------+\n";
    }

    # print debug dump
    if($Conf::log_level>=3){
        print "Dump of \%encoding_check_results:\n";
        print Dumper(\%encoding_check_results);
    }

    # Print Result
    print "S\n";
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "Tested Encodings:",
            "Hits",
            "Errors",
            "Sum";
    print "+---------------------+--------+--------+--------+\n";
    foreach my $enc (@encodings_to_check){
        printf  "| %-20s|%7s |%7s |%7s |\n",
                $enc,
                $encoding_check_results{$file}{'firstnames'}{'count_hits'}{$enc},
                $encoding_check_results{$file}{'firstnames'}{'count_errors'}{$enc},
   	        $encoding_check_results{$file}{'firstnames'}{'count_sum'}{$enc};
    }
    print "+---------------------+--------+--------+--------+\n";
    printf  "| %-20s|%7s |%7s |%7s |\n",
            "none",
            $encoding_check_results{$file}{'firstnames'}{'count_hits'}{'none'},
            "",
            "";
    print "+---------------------+--------+--------+--------+\n";
    print "$file:\n",
          "    File-Encoding is $encoding_check_results{$file}{'firstnames'}{'result'}\n"; 
    print "\n";
    close(DATAFILE);
}
